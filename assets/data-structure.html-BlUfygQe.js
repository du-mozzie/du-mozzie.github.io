import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,o as l,c,a as i,b as n,d as s,e as t,h as e}from"./app-DpapLPne.js";const r="/assets/image-20210418224522556-CAEFeyb-.png",u="/assets/image-20201209160216218-D5i-X6Xh.png",d="/assets/image-20210418220357626-D7fpVuQr.png",k="/assets/image-20210418220439032-C399iKTy.png",g="/assets/image-20210513125707472-B0jg5weF.png",m="/assets/image-20210419215326952-DGZtPE9r.png",h="/assets/image-20210712153740753-BTavrYn1.png",v="/assets/image-20210712153135194-DXR6vni6.png",b="/assets/image-20210712153143568-CkGJyMBI.png",f="/assets/image-20210712153156543-DJPbamxd.png",_="/assets/image-20210712153212846-Dn7JA18G.png",y="/assets/image-20210712153222564-C4I72OsJ.png",x="/assets/image-20210714090259980-DIevNftZ.png",w="/assets/image-20210714090354411-Cr4mB6lw.png",E="/assets/image-20210714090627833-BO3yOz3o.png",A="/assets/image-20210714090911846-Bih5GvmL.png",B="/assets/image-20210712153235112-C_kRBanW.png",q="/assets/image-20210713084911013-CQEdReON.png",L="/assets/image-20210713085101912-DntKR-Du.png",z={},T=e('<h1 id="线性表" tabindex="-1"><a class="header-anchor" href="#线性表"><span>线性表</span></a></h1><p>什么是线性表？</p><p><strong>由同类型数据元素构成有序序列的线性结构</strong></p><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>表中元素个数称为线性表的<strong>长度</strong></li><li>线性表没有元素时，成为<strong>空表</strong></li><li>表起始位置称<strong>表头</strong>，表结束位置称<strong>表尾</strong></li></ul><p>类型名称：线性表(List)</p><p>数据对象集：线性表是n(≥0)个元素构成的有序序列(a<sub>1</sub>，a<sub>2</sub>，......，a<sub>n</sub>)</p><p>操作集：线性表L∈List，整数i表示位置，元素X∈ElementType，线 性表基本操作主要有：</p><figure><img src="'+u+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="顺序存储结构" tabindex="-1"><a class="header-anchor" href="#顺序存储结构"><span>顺序存储结构</span></a></h2><p><strong>数组</strong></p><p>数组是将相同类型的元素存储于连续内存空间的数据结构，其长度不可变。</p><p>查询较快，增删较慢，增加每一个元素都要后移，删除每一个元素都要前移。</p><h2 id="单链表-linklist" tabindex="-1"><a class="header-anchor" href="#单链表-linklist"><span>单链表(LinkList)</span></a></h2><p>链表以节点为单位，每个元素都是一个独立对象，在内存空间的存储是非连续的。链表的节点对象具有两个成员变量：「值 <code>val</code>」，「后继节点引用 <code>next</code>」</p><p>元素无需按顺序排列，只要上一个元素指向下一个元素即可</p><p>创建链表：每一个链表的空间和位置是不需要预先分配划定的，可以根据系统的情况和实际的需求即时生成。</p><blockquote><p>单链表结构与顺序存储结构的优缺点：</p><ol><li>存储分配方式： <ul><li>顺序存储结构用一段连续存储单元依次存储线性表的数据元素</li><li>单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素</li></ul></li><li>时间性能： <ul><li>查找 <ul><li>顺序存储结构O(1)</li><li>单链表O(n)</li></ul></li><li>插入和删除 <ul><li>顺序存储结构需要平均移动表长一半的元素，时间复杂度为O(n)</li><li>单链表在找出位置的指针后，插入和删除时间复杂度仅为O(1)</li></ul></li></ul></li><li>空间性能： <ul><li>顺序存储结构需要预分配存储空间，分大了，浪费；分小了，易发生上溢</li><li>单链表不需要分配存储空间，只要有就可以分配，元素个数不受限制</li></ul></li></ol><p><mark>若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构，反正使用单链表结构</mark></p><p><mark>当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构。</mark></p></blockquote><h2 id="静态链表" tabindex="-1"><a class="header-anchor" href="#静态链表"><span>静态链表</span></a></h2><p><mark>用数组描述的链表叫做静态链表</mark>，数组的每个下标都对应一个data和cur，数据域data用来存放数据元素，游标cur用来指向该元素的后继(类似单链表中的next指针)</p><p>静态链表创建</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSIZE</span> <span class="token expression"><span class="token number">1000</span> </span><span class="token comment">/* 存储空间的初始分配量 */</span></span>

<span class="token comment">/* 线性表的静态链表存储结构 */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">{</span>
    Elemtype data<span class="token punctuation">;</span>
    <span class="token keyword">int</span> cur<span class="token punctuation">;</span>			<span class="token comment">/* 游标(cursor)，为0表示无指向 */</span>
<span class="token punctuation">}</span> Component<span class="token punctuation">,</span>StaticLinkList<span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><mark>第一个跟最后一个元素不存数据</mark></p><p>第一个cur存储空闲空间第一个结点的下标，最后一个cur存储第一个元素的下标</p><figure><img src="`+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>第一个cur指向备用链表的第一个结点，最后一个cur指向第一个数据</p><figure><img src="'+k+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p>优点：</p><p>​ 在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中插入和删除操作需要移动大量元素的缺点。</p><p>缺点：</p><p>​ 没有解决连续存储分配带来的表长难以确定的问题，失去了链式存储结构随机存取的特性</p></blockquote><h2 id="循环链表" tabindex="-1"><a class="header-anchor" href="#循环链表"><span>循环链表</span></a></h2><p><mark>将单链表中终端节点的指针指向头结点，形成一个环，这就是循环链表</mark></p><h2 id="双向链表" tabindex="-1"><a class="header-anchor" href="#双向链表"><span>双向链表</span></a></h2><p><mark>在单链表的每个节点中在设置一个前驱指针</mark>，两个指针一个指向后继节点，一个指向前驱节点</p><h1 id="栈和队列" tabindex="-1"><a class="header-anchor" href="#栈和队列"><span>栈和队列</span></a></h1><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>push：插入</p><p>pop：删除</p><p>peek：查看顶部</p><h2 id="栈-stack" tabindex="-1"><a class="header-anchor" href="#栈-stack"><span>栈(stack)</span></a></h2><p><mark>栈是限定仅在表尾进行插入和删除的线性表</mark></p><p>允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈。</p><p>后进先出LIFO</p><blockquote><p>栈的插入操作，叫作进栈，也称压栈、入栈。</p><p>栈的删除操作，叫作出栈，有的也叫作弹栈。</p></blockquote><figure><img src="'+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>逆波兰，使用栈结构来帮助计算机处理数学加减乘除计算问题</strong></p><p>​ 把生活中数学中缀表示法改成后缀表示法</p><p>​ 逆波兰记法中，操作符置于操作数的后面。例如表达“三加四”时，写作“3 4 + ”，而不是“3 + 4”。如果有多个操作符，操作符置于第二个操作数的后面，所以常规中缀记法的“3 - 4 + 5”在逆波兰记法中写作“3 4 - 5 + ”：先3减去4，再加上5。使用逆波兰记法的一个好处是不需要使用括号。例如中缀记法中“3 - 4 * 5”与“（3 - 4）*5”不相同，但后缀记法中前者写做“3 4 5 * - ”，无歧义地表示“3 (4 5 *) -”；后者写做“3 4 - 5 * ”。</p>',46),I={href:"https://zh.wikipedia.org/wiki/%E8%A7%A3%E9%87%8A%E5%99%A8",target:"_blank",rel:"noopener noreferrer"},S={href:"https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88",target:"_blank",rel:"noopener noreferrer"},D=e('<h2 id="队列-queue" tabindex="-1"><a class="header-anchor" href="#队列-queue"><span>队列(Queue)</span></a></h2><p><mark>队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表</mark></p><p>先进先出FIFO</p><blockquote><p>循环队列、双端队列Deque</p></blockquote><p>支持两端元素插入和移除的线性集合，头尾相接的顺序存储结构，插入删除不需要申请和释放节点，扩充空间较为麻烦</p><blockquote><p>链队列</p></blockquote><p>使用链式结构存储元素，有指针，插入删除需要申请和释放节点，扩充空间较为简便</p><h1 id="字符串" tabindex="-1"><a class="header-anchor" href="#字符串"><span>字符串</span></a></h1><p>由零个或多个字符串组成的有限序列</p><blockquote><p>回文</p></blockquote><p>正序、逆序，串是一样的</p><blockquote><p>串的比较</p></blockquote><p>根据ASCII或者Unicode编码逐个比较字符串的字符比较排序大小</p><blockquote><p>存储结构</p></blockquote><ol><li><p>顺序存储结构</p><p>用一组地址连续的存储单元赖存储串中的字符序列</p></li><li><p>链式存储结构</p><p>使用链表来存储串</p></li></ol><blockquote><p>模式匹配算法</p></blockquote>',16),j=n("li",null,[n("p",null,"朴素的模式匹配算法"),n("p",null,"逐个遍历元素匹配")],-1),C={href:"https://www.zhihu.com/question/21923021/answer/1032665486",target:"_blank",rel:"noopener noreferrer"},F=n("h1",{id:"树",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#树"},[n("span",null,"树")])],-1),N=n("figure",null,[n("img",{src:h,alt:"",tabindex:"0",loading:"lazy"}),n("figcaption")],-1),V=n("strong",null,"树状图",-1),O={href:"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450",target:"_blank",rel:"noopener noreferrer"},R={href:"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E9%9B%86%E5%90%88",target:"_blank",rel:"noopener noreferrer"},M=e('<p>**它具有以下的特点：**每个结点有零个或多个子结点；没有父结点的结点称为根结点；每一个非根结点有且只有一个父结点；除了根结点外，每个子结点可以分为多个不相交的子树；</p><p><strong>树结构是一种非线性存储结构，存储的是具有“一对多”关系的数据元素的集合。</strong></p><h2 id="术语" tabindex="-1"><a class="header-anchor" href="#术语"><span>术语</span></a></h2><blockquote><p>节点深度：对任意节点x，x节点的深度表示为根节点到x节点的路径长度。所以根节点深度为0，第二层节点深度为1，以此类推</p><p>节点高度：对任意节点x，叶子节点到x节点的路径长度就是节点x的高度</p><p>树的深度：一棵树中节点的最大深度就是树的深度，也称为高度</p><p>父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点</p><p>子节点：一个节点含有的子树的根节点称为该节点的子节点</p><p>节点的层次：从根节点开始，根节点为第一层，根的子节点为第二层，以此类推</p><p>兄弟节点：拥有共同父节点的节点互称为兄弟节点</p><p>度：节点的子树数目就是节点的度</p><p>叶子节点：度为零的节点就是叶子节点</p><p>祖先：对任意节点x，从根节点到节点x的所有节点都是x的祖先（节点x也是自己的祖先）</p><p>后代：对任意节点x，从节点x到叶子节点的所有节点都是x的后代（节点x也是自己的后代）</p><p>森林：m颗互不相交的树构成的集合就是森林</p></blockquote><h2 id="树的种类" tabindex="-1"><a class="header-anchor" href="#树的种类"><span>树的种类</span></a></h2><h3 id="无序树" tabindex="-1"><a class="header-anchor" href="#无序树"><span><strong>无序树</strong></span></a></h3><p>树的任意节点的子节点没有顺序关系。</p><h3 id="有序树" tabindex="-1"><a class="header-anchor" href="#有序树"><span><strong>有序树</strong></span></a></h3><p>树的任意节点的子节点有顺序关系。</p><h3 id="二叉树" tabindex="-1"><a class="header-anchor" href="#二叉树"><span>二叉树</span></a></h3><p>树的任意节点至多包含两棵子树。</p><p>二叉树遍历:</p><p>二叉树的遍历是指从二叉树的根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次，且仅被访问一次。</p><p><strong>二叉树的访问次序可以分为四种：</strong></p><p>前序遍历 中序遍历 后序遍历 层次遍历</p><p><code>二叉树的性质</code></p><p>二叉树有以下几个性质：TODO(上标和下标)</p><p><strong>性质1</strong>：二叉树第i层上的结点数目最多为 <strong>2<sup>i-1</sup></strong> (i≥1)。</p><p><strong>性质2</strong>：深度为k的二叉树至多有<strong>2<sup>k</sup>-1</strong>个结点(k≥1)。</p><p><strong>性质3</strong>：包含n个结点的二叉树的高度至少为**(log<sub>2</sub>n)+1)**。</p><p><strong>性质4</strong>：在任意一棵二叉树中，若终端结点的个数为<strong>n0</strong>，度为2的结点数为<strong>n2</strong>，则<strong>n0=n2+1</strong>。</p><p><strong>2.1 性质1：二叉树第i层上的结点数目最多为 2{i-1} (i≥1)</strong></p><p>证明：下面用&quot;数学归纳法&quot;进行证明。 (01) 当i=1时，第i层的节点数目为2{i-1}=2{0}=1。因为第1层上只有一个根结点，所以命题成立。 (02) 假设当i&gt;1，第i层的节点数目为2{i-1}。这个是根据(01)推断出来的！ 下面根据这个假设，推断出&quot;第(i+1)层的节点数目为2{i}&quot;即可。 由于二叉树的每个结点至多有两个孩子，故&quot;第(i+1)层上的结点数目&quot; 最多是 &quot;第i层的结点数目的2倍&quot;。即，第(i+1)层上的结点数目最大值=2×2{i-1}=2{i}。 故假设成立，原命题得证！</p><p><strong>2.2 性质2：深度为k的二叉树至多有2{k}-1个结点(k≥1)</strong></p><p>证明：在具有相同深度的二叉树中，当每一层都含有最大结点数时，其树中结点数最多。利用&quot;性质1&quot;可知，深度为k的二叉树的结点数至多为： 20+21+…+2k-1=2k-1 故原命题得证！</p><p><strong>2.3 性质3：包含n个结点的二叉树的高度至少为log2 (n+1)</strong></p><p>证明：根据&quot;性质2&quot;可知，高度为h的二叉树最多有2{h}–1个结点。反之，对于包含n个节点的二叉树的高度至少为log2(n+1)。</p><p><strong>2.4 性质4：在任意一棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则n0=n2+1</strong></p><p>证明：因为二叉树中所有结点的度数均不大于2，所以结点总数(记为n)=&quot;0度结点数(n0)&quot; + &quot;1度结点数(n1)&quot; + &quot;2度结点数(n2)&quot;。由此，得到等式一。 (等式一) n=n0+n1+n2 　 另一方面，0度结点没有孩子，1度结点有一个孩子，2度结点有两个孩子，故二叉树中孩子结点总数是：n1+2n2。此外，只有根不是任何结点的孩子。故二叉树中的结点总数又可表示为等式二。 (等式二) n=n1+2n2+1 由(等式一)和(等式二)计算得到：n0=n2+1。原命题得证！</p><h3 id="满二叉树" tabindex="-1"><a class="header-anchor" href="#满二叉树"><span><strong>满二叉树</strong></span></a></h3><p>叶子节点都在同一层并且除叶子节点外的所有节点都有两个子节点。</p><p><img src="'+v+'" alt="" loading="lazy">满二叉树</p><h3 id="完全二叉树" tabindex="-1"><a class="header-anchor" href="#完全二叉树"><span><strong>完全二叉树</strong></span></a></h3><p>对于一颗二叉树，假设其深度为d（d&gt;1）。除第d层外的所有节点构成满 二叉树，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；</p><p><img src="'+b+'" alt="" loading="lazy">完全二叉树</p><ol><li>叶子结点只能出现在最下两层。</li><li>最下层的叶子一定集中在左部连续位置。</li><li>倒数二层，若有叶子结点，一定都在右部连续位置。</li><li>如果结点度为1,则该结点只有左孩子，即不存在只有右子树的情况。</li><li>同样结点数的二叉树，完全二叉树的深度最小。</li></ol><h3 id="完满二叉树" tabindex="-1"><a class="header-anchor" href="#完满二叉树"><span><strong>完满二叉树</strong></span></a></h3><p><img src="'+f+'" alt="" loading="lazy">完满二叉树</p><figure><img src="'+_+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="哈夫曼树" tabindex="-1"><a class="header-anchor" href="#哈夫曼树"><span><strong>哈夫曼树</strong></span></a></h3><p>带权路径最短的二叉树称为哈夫曼树或最优二叉树。</p><h3 id="二叉查找树" tabindex="-1"><a class="header-anchor" href="#二叉查找树"><span><strong>二叉查找树</strong></span></a></h3><p>（二叉搜索树、二叉排序树、BST）[这几个都是别名]</p><p>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</p><p>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</p><p>任意节点的左、右子树也分别为二叉查找树；``</p><p>没有键值相等的节点。</p><h3 id="线索二叉树" tabindex="-1"><a class="header-anchor" href="#线索二叉树"><span>线索二叉树</span></a></h3>',48),P={href:"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91/1602879",target:"_blank",rel:"noopener noreferrer"},Z=n("h3",{id:"平衡二叉树",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#平衡二叉树"},[n("span",null,"平衡二叉树")])],-1),G=n("p",null,"它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树，同时，平衡二叉树必定是二叉搜索树。",-1),X=n("h3",{id:"avl树",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#avl树"},[n("span",null,"AVL树")])],-1),J=n("strong",null,"AVL树",-1),Q=n("strong",null,"高度平衡树",-1),K={href:"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E6%A0%91%E6%97%8B%E8%BD%AC",target:"_blank",rel:"noopener noreferrer"},W=e('<p>AVL树本质上还是一棵二叉搜索树，它的特点是：</p><ol><li>本身首先是一棵二叉搜索树。</li><li>带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1。</li></ol><p>也就是说，AVL树，本质上是带了平衡功能的二叉查找树（二叉排序树，二叉搜索树）。</p><p><strong>使用场景：</strong></p><ul><li>AVL树适合用于插入删除次数比较少，但查找多的情况。</li><li>也在<code>Windows</code>进程地址空间管理中得到了使用</li><li>旋转的目的是为了降低树的高度，使其平衡</li></ul><h3 id="红黑树" tabindex="-1"><a class="header-anchor" href="#红黑树"><span><strong>红黑树</strong></span></a></h3><p>红黑树是每个节点都带有颜色属性的二叉查找树，颜色或红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:</p><ul><li>性质1. 节点是红色或黑色。</li><li>性质2. 根节点是黑色。</li><li>性质3. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li><li>性质4. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</li></ul><p><strong>使用场景：</strong></p><p>红黑树多用于搜索,插入,删除操作多的情况下红黑树应用比较广泛：</p><ul><li><p>广泛用在<code>C++</code>的<code>STL</code>中。<code>map</code>和<code>set</code>都是用红黑树实现的。</p></li><li><p>著名的<code>linux</code>进程调度<code>Completely Fair Scheduler</code>,用红黑树管理进程控制块。</p></li><li><p><code>epoll</code>在内核中的实现，用红黑树管理事件块</p></li><li><p><code>nginx</code>中，用红黑树管理<code>timer</code>等</p></li></ul><h3 id="伸展树" tabindex="-1"><a class="header-anchor" href="#伸展树"><span>伸展树</span></a></h3>',12),H={href:"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/10905079",target:"_blank",rel:"noopener noreferrer"},Y=n("strong",null,"丹尼尔·斯立特",-1),U=n("strong",null,"罗伯特·恩卓·塔扬",-1),$=n("p",null,"Robert Endre Tarjan 在1985年发明的。",-1),nn=n("p",null,"​ 在伸展树上的一般操作都基于伸展操作：假设想要对一个二叉查找树执行一系列的查找操作，为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。于是想到设计一个简单方法， 在每次查找之后对树进行重构，把被查找的条目搬移到离树根近一些的地方。伸展树应运而生。伸展树是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列的旋转把这个节点搬移到树根去。它的优势在于不需要记录用于平衡树的冗余信息。",-1),sn=n("h3",{id:"替罪羊树",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#替罪羊树"},[n("span",null,"替罪羊树")])],-1),an={href:"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/9132",target:"_blank",rel:"noopener noreferrer"},tn={href:"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6",target:"_blank",rel:"noopener noreferrer"},en={href:"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/O",target:"_blank",rel:"noopener noreferrer"},pn={href:"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91",target:"_blank",rel:"noopener noreferrer"},on=e('<h3 id="b-tree-b-树或者b树" tabindex="-1"><a class="header-anchor" href="#b-tree-b-树或者b树"><span>B-tree（B-树或者B树）</span></a></h3><p>一棵m阶B树(balanced tree of order m)是一棵平衡的m路搜索树。它或者是空树，或者是满足下列性质的树：</p><ol><li>根结点至少有两个子女；</li><li>每个非根节点所包含的关键字个数 j 满足：┌m/2┐ - 1 &lt;= j &lt;= m - 1；</li><li>除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加1，故<strong>内部子树</strong>个数 k 满足：┌m/2┐ &lt;= k &lt;= m ；</li><li>所有的叶子结点都位于同一层。</li></ol><figure><img src="'+y+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>B树(B-Tree)是一种自平衡的树,它是一种多路搜索树（并不是二叉的），能够保证数据有序。同时它还保证了在查找、插入、删除等操作时性能都能保持在<code>O(logn)</code>，为大块数据的读写操作做了优化,同时它也可以用来描述外部存储(支持对保存在磁盘或者网络上的符号表进行外部查找)</p><p><strong>B+树</strong></p><p>B+树是B树的一种变形形式，B+树上的叶子结点存储关键字以及相应记录的地址，叶子结点以上各层作为索引使用。一棵m阶的B+树定义如下:</p><ol><li>每个结点至多有m个子女；</li><li>除根结点外，每个结点至少有[m/2]个子女，根结点至少有两个子女；</li><li>有k个子女的结点必有k个关键字。</li></ol><p>B+树的查找与B树不同，当索引部分某个结点的关键字与所查的关键字相等时，并不停止查找，应继续沿着这个关键字左边的指针向下，一直查到该关键字所在的叶子结点为止。</p><p><strong>更适合文件索引系统</strong></p><p>原因： 增删文件（节点）时，效率更高，因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率</p><p><strong>使用场景：</strong></p><p>*文件系统和数据库系统中常用的B/B+ 树，他通过对每个节点存储个数的扩展，使得对连续的数据能够进行较快的定位和访问，能够有效减少查找时间，提高存</p><p><strong>储的空间局部性从而减少IO操作。他广泛用于文件系统及数据库中，如：</strong></p><ul><li>Windows：HPFS 文件系统</li><li>Mac：HFS，HFS+ 文件系统</li><li>Linux：ResiserFS，XFS，Ext3FS，JFS 文件系统</li><li>数据库：ORACLE，MYSQL，SQLSERVER 等中</li><li>B树：有序数组+平衡多叉树</li><li>B+树：有序数组链表+平衡多叉树</li></ul><p><strong>B*树</strong></p><p>​ B<em>树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；B</em>树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）。</p><p>​ B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；</p><p>​ B树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；</p><p>所以，B*树分配新结点的概率比B+树要低，空间使用率更高；</p><h3 id="字典树" tabindex="-1"><a class="header-anchor" href="#字典树"><span>字典树</span></a></h3>',21),ln={href:"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/Trie%E6%A0%91",target:"_blank",rel:"noopener noreferrer"},cn={href:"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84/9663807",target:"_blank",rel:"noopener noreferrer"},rn={href:"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%AD%97%E7%AC%A6",target:"_blank",rel:"noopener noreferrer"},un=e('<p>它有3个基本性质：</p><ol><li>根节点不包含字符，除根节点外每一个节点都只包含一个字符；</li><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串；</li><li>每个节点的所有子节点包含的字符都不相同。</li></ol><h2 id="二叉树遍历" tabindex="-1"><a class="header-anchor" href="#二叉树遍历"><span>二叉树遍历</span></a></h2><h3 id="前序遍历" tabindex="-1"><a class="header-anchor" href="#前序遍历"><span>前序遍历</span></a></h3><p><strong>第一次成为栈顶元素的时候</strong></p><p><code>根在前，从左往右，一棵树的根永远在左子树前面，左子树又永远在右子树前面(根左右) </code></p><p>前序遍历（DLR），是二叉树遍历的一种，也叫做先根遍历、先序遍历、前序周游，可记做根左右。前序遍历首先访问根结点然后遍历左子树，最后遍历右子树。</p><p>前序遍历首先访问根结点然后遍历左子树，最后遍历右子树。在遍历左、右子树时，仍然先访问根结点，然后遍历左子树，最后遍历右子树。</p><p>若二叉树为空则结束返回，否则：</p><p>（1）访问根结点。</p><p>（2）前序遍历左子树**。**</p><p>（3）前序遍历右子树 。</p><figure><img src="'+x+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>需要注意的是：遍历左右子树时仍然采用前序遍历方法。</p><p>如右图所示二叉树</p><p>前序遍历结果：ABDECF</p><blockquote><p>递归</p></blockquote><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">perorder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">perorder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> node<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> res<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">perorder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">perorder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>迭代</p></blockquote><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> res<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> root<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> node <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
                node <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            node <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="中序遍历" tabindex="-1"><a class="header-anchor" href="#中序遍历"><span>中序遍历</span></a></h3><p><strong>第二次成为栈顶元素的时候</strong></p><p><code>根在中，从左往右，一棵树的左子树永远在根前面，根永远在右子树前面(左根右)</code></p><p>中序遍历（LDR）是二叉树遍历的一种，也叫做中根遍历、中序周游。在二叉树中，中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。</p><p>中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。若二叉树为空则结束返回，否则：</p><p>（1）中序遍历左子树</p><p>（2）访问根结点</p><p>（3）中序遍历右子树</p><figure><img src="`+w+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如右图所示二叉树，中序遍历结果：DBEAFC</p><blockquote><p>递归</p></blockquote><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">inorder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> node<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> res<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token function">inorder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">inorder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="后序遍历" tabindex="-1"><a class="header-anchor" href="#后序遍历"><span>后序遍历</span></a></h3><p><strong>第三次成为栈顶元素的时候</strong></p><p><code>根在后，从左往右，一棵树的左子树永远在右子树前面，右子树永远在根前面(左右根)</code></p><p>后序遍历（LRD）是二叉树遍历的一种，也叫做后根遍历、后序周游，可记做左右根。后序遍历有递归算法和非递归算法两种。在二叉树中，先左后右再根，即首先遍历左子树，然后遍历右子树，最后访问根结点。</p><p>后序遍历首先遍历左子树，然后遍历右子树，最后访问根结点，在遍历左、右子树时，仍然先遍历左子树，然后遍历右子树，最后遍历根结点。即：</p><p>若二叉树为空则结束返回，</p><p>否则：</p><p>（1）后序遍历左子树</p><p>（2）后序遍历右子树</p><p>（3）访问根结点</p><figure><img src="`+E+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如右图所示二叉树</p><p>后序遍历结果：DEBFCA</p><p>已知前序遍历和中序遍历，就能确定后序遍历。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">postorder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postorder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> node<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> res<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token function">postorder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">postorder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="层序遍历" tabindex="-1"><a class="header-anchor" href="#层序遍历"><span>层序遍历</span></a></h3><p>层序遍历，就是按层，从上到下，从左到右遍历</p><figure><img src="`+A+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p>递归</p></blockquote><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>	

<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
	<span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//用来存放最终结果</span>
		<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>root<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> res<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">//假设res是[ [1],[2,3] ]， index是3，就再插入一个空list放到res中</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//将当前节点的值加入到res中，index代表当前层，假设index是3，节点值是99</span>
		<span class="token comment">//res是[ [1],[2,3] [4] ]，加入后res就变为 [ [1],[2,3] [4,99] ]</span>
		res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//递归的处理左子树，右子树，同时将层数index+1</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token function">dfs</span><span class="token punctuation">(</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token function">dfs</span><span class="token punctuation">(</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="morris遍历" tabindex="-1"><a class="header-anchor" href="#morris遍历"><span>Morris遍历</span></a></h3><p>Morris遍历细节</p><p>假设来到当前节点cur，开始时cur来到头节点位置</p><ol><li>如果cur没有左孩子，cur向右移动(cur = cur.right)</li><li>如果cur有左孩子，找到左子树上最右的节点mostRight: <ul><li>如果mostRight的右指针指向空，让其指向cur,然后cur向左移动(cur = cur.left)</li><li>如果mostRight的右指针指向cur，让其指向null,然后cur向右移动(cur = cur.right)</li></ul></li><li>cur为空时遍历停止</li></ol><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><figure><img src="`+B+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h1 id="图-graph" tabindex="-1"><a class="header-anchor" href="#图-graph"><span>图(Graph)</span></a></h1>',59),dn={href:"https://d3gt.com/index.html",target:"_blank",rel:"noopener noreferrer"},kn=e('<figure><img src="'+q+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><code>节点(Vertex)</code> 与 <code>边（Edge）</code></li><li>图的表示： <code>邻接表</code> 和 <code>邻接矩阵</code><ul><li>这里可以分为 <code>有向图</code> 和<code>无向图</code><code>无向图是一种特殊的有向图</code></li><li><code>有权图</code> 和 <code>无权图</code></li></ul></li><li>图的遍历： <code>(广度优先搜索)DFS</code> <code>(深度优先搜索)BFS</code> 常见可以解决的问题有： <code>联通分量</code> <code>Flood Fill</code> <code>寻路</code> <code>走迷宫</code> <code>迷宫生成</code> <code>无权图的最短路径</code> <code>环的判断</code></li><li>最小生成树问题（Minimum Spanning Tree） <code>Prim</code> <code>Kruskal</code></li><li>最短路径问题(Shortest Path) <code>Dijkstra</code> <code>Bellman-Ford</code></li><li>拓扑排序(Topological sorting)</li></ul><blockquote><p>图的定义</p></blockquote><h2 id="术语-1" tabindex="-1"><a class="header-anchor" href="#术语-1"><span>术语</span></a></h2><h3 id="什么是图" tabindex="-1"><a class="header-anchor" href="#什么是图"><span>什么是图</span></a></h3><p>图是一种复杂的非线性结构。</p><p>在线性结构中，数据元素之间满足唯一的线性关系，每个数据元素(除第一个和最后一个外)只有一个直接前趋和一个直接后继；</p><p>在树形结构中，数据元素之间有着明显的层次关系，并且每个数据元素只与上一层中的一个元素(parent node)及下一层的多个元素(孩子节点)相关；</p><p>而在图形结构中，节点之间的关系是任意的，图中任意两个数据元素之间都有可能相关。</p><p><strong>图G由两个集合V(顶点Vertex)和E(边Edge)组成，定义为G=(V，E)</strong></p><blockquote><p>图相关的概念和术语</p></blockquote><h3 id="无向图和有向图" tabindex="-1"><a class="header-anchor" href="#无向图和有向图"><span>无向图和有向图</span></a></h3><p>对于一个图，若每条边都是没有方向的，则称该图为无向图。图示如下：</p><figure><img src="'+L+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>因此，(Vi，Vj)和(Vj，Vi)表示的是同一条边。注意，无向图是用小括号</p><p>无向图的顶点集和边集分别表示为：</p>',16);function gn(mn,hn){const a=o("ExternalLinkIcon");return l(),c("div",null,[i(" more "),T,n("p",null,[s("逆波兰表达式的"),n("a",I,[s("解释器"),t(a)]),s("一般是基于"),n("a",S,[s("堆栈"),t(a)]),s("的。解释过程一般是：操作数入栈；遇到操作符时，操作数出栈，求值，将结果入栈；当一遍后，栈顶就是表达式的值。因此逆波兰表达式的求值使用堆栈结构很容易实现，并且能很快求值。")]),D,n("ol",null,[j,n("li",null,[n("p",null,[n("a",C,[s("KMP模式匹配算法"),t(a)])])])]),F,N,n("p",null,[V,s("是一种"),n("a",O,[s("数据结构"),t(a)]),s("，它是由n（n>=1）个有限结点组成一个具有层次关系的"),n("a",R,[s("集合"),t(a)]),s("。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。")]),M,n("p",null,[s("​ 在"),n("a",P,[s("二叉树"),t(a)]),s("的结点上加上线索的二叉树称为线索二叉树，对二叉树以某种遍历方式（如先序、中序、后序或层次等）进行遍历，使其变为线索二叉树的过程称为对二叉树进行线索化。")]),Z,G,X,n("p",null,[s("在计算机科学中，"),J,s("是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为"),Q,s("。增加和删除可能需要通过一次或多次"),n("a",K,[s("树旋转"),t(a)]),s("来重新平衡这个树。")]),W,n("p",null,[s("​ 伸展树（Splay Tree），也叫分裂树，是一种"),n("a",H,[s("二叉排序树"),t(a)]),s("，它能在O(log n)内完成插入、查找和删除操作。它由"),Y,s("Daniel Sleator 和 "),U]),$,nn,sn,n("p",null,[s("​ 替罪羊树是"),n("a",an,[s("计算机科学"),t(a)]),s("中，一种基于部分重建的自平衡二叉搜索树。在替罪羊树上，插入或删除节点的平摊最坏"),n("a",tn,[s("时间复杂度"),t(a)]),s("是"),n("a",en,[s("O"),t(a)]),s("(log n)，搜索节点的最坏时间复杂度是O(log n)。")]),n("p",null,[s("​ 在非平衡的"),n("a",pn,[s("二叉搜索树"),t(a)]),s("中，每次操作以后检查操作路径，找到最高的满足max(size(son_L),size(son_R))>alpha*size(this)的结点，重建整个子树。这样就得到了替罪羊树，而被重建的子树的原来的根就被称为替罪羊节点。替罪羊树替罪羊树是一棵自平衡二叉搜索树，由ArneAndersson提出。替罪羊树的主要思想就是将不平衡的树压成一个序列,然后暴力重构成一颗平衡的树。")]),on,n("p",null,[s("​ 又称单词查找树，"),n("a",ln,[s("Trie树"),t(a)]),s("，是一种"),n("a",cn,[s("树形结构"),t(a)]),s("，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的"),n("a",rn,[s("字符"),t(a)]),s("串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。")]),un,n("p",null,[n("a",dn,[s("以交互方式学习图论"),t(a)])]),kn])}const fn=p(z,[["render",gn],["__file","data-structure.html.vue"]]),_n=JSON.parse('{"path":"/code/data-structure-and-algorithms/data-structure.html","title":"数据结构","lang":"zh-CN","frontmatter":{"order":1,"title":"数据结构","date":"2020-12-26T00:00:00.000Z","category":"数据结构与算法","timeline":true,"article":false,"prev":"../","head":[["meta",{"property":"og:url","content":"https://du-mozzie.github.io/code/data-structure-and-algorithms/data-structure.html"}],["meta",{"property":"og:title","content":"数据结构"}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-07T09:54:00.000Z"}],["meta",{"property":"article:author","content":"Du"}],["meta",{"property":"article:published_time","content":"2020-12-26T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-07T09:54:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"数据结构\\"}"]]},"headers":[{"level":2,"title":"顺序存储结构","slug":"顺序存储结构","link":"#顺序存储结构","children":[]},{"level":2,"title":"单链表(LinkList)","slug":"单链表-linklist","link":"#单链表-linklist","children":[]},{"level":2,"title":"静态链表","slug":"静态链表","link":"#静态链表","children":[]},{"level":2,"title":"循环链表","slug":"循环链表","link":"#循环链表","children":[]},{"level":2,"title":"双向链表","slug":"双向链表","link":"#双向链表","children":[]},{"level":2,"title":"栈(stack)","slug":"栈-stack","link":"#栈-stack","children":[]},{"level":2,"title":"队列(Queue)","slug":"队列-queue","link":"#队列-queue","children":[]},{"level":2,"title":"术语","slug":"术语","link":"#术语","children":[]},{"level":2,"title":"树的种类","slug":"树的种类","link":"#树的种类","children":[{"level":3,"title":"无序树","slug":"无序树","link":"#无序树","children":[]},{"level":3,"title":"有序树","slug":"有序树","link":"#有序树","children":[]},{"level":3,"title":"二叉树","slug":"二叉树","link":"#二叉树","children":[]},{"level":3,"title":"满二叉树","slug":"满二叉树","link":"#满二叉树","children":[]},{"level":3,"title":"完全二叉树","slug":"完全二叉树","link":"#完全二叉树","children":[]},{"level":3,"title":"完满二叉树","slug":"完满二叉树","link":"#完满二叉树","children":[]},{"level":3,"title":"哈夫曼树","slug":"哈夫曼树","link":"#哈夫曼树","children":[]},{"level":3,"title":"二叉查找树","slug":"二叉查找树","link":"#二叉查找树","children":[]},{"level":3,"title":"线索二叉树","slug":"线索二叉树","link":"#线索二叉树","children":[]},{"level":3,"title":"平衡二叉树","slug":"平衡二叉树","link":"#平衡二叉树","children":[]},{"level":3,"title":"AVL树","slug":"avl树","link":"#avl树","children":[]},{"level":3,"title":"红黑树","slug":"红黑树","link":"#红黑树","children":[]},{"level":3,"title":"伸展树","slug":"伸展树","link":"#伸展树","children":[]},{"level":3,"title":"替罪羊树","slug":"替罪羊树","link":"#替罪羊树","children":[]},{"level":3,"title":"B-tree（B-树或者B树）","slug":"b-tree-b-树或者b树","link":"#b-tree-b-树或者b树","children":[]},{"level":3,"title":"字典树","slug":"字典树","link":"#字典树","children":[]}]},{"level":2,"title":"二叉树遍历","slug":"二叉树遍历","link":"#二叉树遍历","children":[{"level":3,"title":"前序遍历","slug":"前序遍历","link":"#前序遍历","children":[]},{"level":3,"title":"中序遍历","slug":"中序遍历","link":"#中序遍历","children":[]},{"level":3,"title":"后序遍历","slug":"后序遍历","link":"#后序遍历","children":[]},{"level":3,"title":"层序遍历","slug":"层序遍历","link":"#层序遍历","children":[]},{"level":3,"title":"Morris遍历","slug":"morris遍历","link":"#morris遍历","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"术语","slug":"术语-1","link":"#术语-1","children":[{"level":3,"title":"什么是图","slug":"什么是图","link":"#什么是图","children":[]},{"level":3,"title":"无向图和有向图","slug":"无向图和有向图","link":"#无向图和有向图","children":[]}]}],"git":{"createdTime":1715063758000,"updatedTime":1715075640000,"contributors":[{"name":"du","email":"25484255238@qq.com","commits":2}]},"readingTime":{"minutes":25.08,"words":7525},"filePathRelative":"code/data-structure-and-algorithms/data-structure.md","localizedDate":"2020年12月26日","excerpt":""}');export{fn as comp,_n as data};
