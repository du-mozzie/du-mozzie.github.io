import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,o as c,c as l,b as n,d as s,e as t,h as e}from"./app-DyRm6WTi.js";const i={},u=n("h1",{id:"树",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#树"},[n("span",null,"树")])],-1),r=n("strong",null,"树状图",-1),k={href:"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450",target:"_blank",rel:"noopener noreferrer"},d={href:"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E9%9B%86%E5%90%88",target:"_blank",rel:"noopener noreferrer"},m=e('<figure><img src="https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20210712153740753.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>**它具有以下的特点：**每个结点有零个或多个子结点；没有父结点的结点称为根结点；每一个非根结点有且只有一个父结点；除了根结点外，每个子结点可以分为多个不相交的子树；</p><p><strong>树结构是一种非线性存储结构，存储的是具有“一对多”关系的数据元素的集合。</strong></p><h2 id="术语" tabindex="-1"><a class="header-anchor" href="#术语"><span>术语</span></a></h2><blockquote><p>节点深度：对任意节点x，x节点的深度表示为根节点到x节点的路径长度。所以根节点深度为0，第二层节点深度为1，以此类推</p><p>节点高度：对任意节点x，叶子节点到x节点的路径长度就是节点x的高度</p><p>树的深度：一棵树中节点的最大深度就是树的深度，也称为高度</p><p>父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点</p><p>子节点：一个节点含有的子树的根节点称为该节点的子节点</p><p>节点的层次：从根节点开始，根节点为第一层，根的子节点为第二层，以此类推</p><p>兄弟节点：拥有共同父节点的节点互称为兄弟节点</p><p>度：节点的子树数目就是节点的度</p><p>叶子节点：度为零的节点就是叶子节点</p><p>祖先：对任意节点x，从根节点到节点x的所有节点都是x的祖先（节点x也是自己的祖先）</p><p>后代：对任意节点x，从节点x到叶子节点的所有节点都是x的后代（节点x也是自己的后代）</p><p>森林：m颗互不相交的树构成的集合就是森林</p></blockquote><h2 id="树的种类" tabindex="-1"><a class="header-anchor" href="#树的种类"><span>树的种类</span></a></h2><h3 id="无序树" tabindex="-1"><a class="header-anchor" href="#无序树"><span><strong>无序树</strong></span></a></h3><p>树的任意节点的子节点没有顺序关系。</p><h3 id="有序树" tabindex="-1"><a class="header-anchor" href="#有序树"><span><strong>有序树</strong></span></a></h3><p>树的任意节点的子节点有顺序关系。</p><h3 id="二叉树" tabindex="-1"><a class="header-anchor" href="#二叉树"><span>二叉树</span></a></h3><p>树的任意节点至多包含两棵子树。</p><p>二叉树遍历:</p><p>二叉树的遍历是指从二叉树的根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次，且仅被访问一次。</p><p><strong>二叉树的访问次序可以分为四种：</strong></p><p>前序遍历 中序遍历 后序遍历 层次遍历</p><p><code>二叉树的性质</code></p><p>二叉树有以下几个性质：TODO(上标和下标)</p><p><strong>性质1</strong>：二叉树第i层上的结点数目最多为 <strong>2<sup>i-1</sup></strong> (i≥1)。</p><p><strong>性质2</strong>：深度为k的二叉树至多有<strong>2<sup>k</sup>-1</strong>个结点(k≥1)。</p><p><strong>性质3</strong>：包含n个结点的二叉树的高度至少为**(log<sub>2</sub>n)+1)**。</p><p><strong>性质4</strong>：在任意一棵二叉树中，若终端结点的个数为<strong>n0</strong>，度为2的结点数为<strong>n2</strong>，则<strong>n0=n2+1</strong>。</p><p><strong>2.1 性质1：二叉树第i层上的结点数目最多为 2{i-1} (i≥1)</strong></p><p>证明：下面用&quot;数学归纳法&quot;进行证明。 (01) 当i=1时，第i层的节点数目为2{i-1}=2{0}=1。因为第1层上只有一个根结点，所以命题成立。 (02) 假设当i&gt;1，第i层的节点数目为2{i-1}。这个是根据(01)推断出来的！ 下面根据这个假设，推断出&quot;第(i+1)层的节点数目为2{i}&quot;即可。 由于二叉树的每个结点至多有两个孩子，故&quot;第(i+1)层上的结点数目&quot; 最多是 &quot;第i层的结点数目的2倍&quot;。即，第(i+1)层上的结点数目最大值=2×2{i-1}=2{i}。 故假设成立，原命题得证！</p><p><strong>2.2 性质2：深度为k的二叉树至多有2{k}-1个结点(k≥1)</strong></p><p>证明：在具有相同深度的二叉树中，当每一层都含有最大结点数时，其树中结点数最多。利用&quot;性质1&quot;可知，深度为k的二叉树的结点数至多为： 20+21+…+2k-1=2k-1 故原命题得证！</p><p><strong>2.3 性质3：包含n个结点的二叉树的高度至少为log2 (n+1)</strong></p><p>证明：根据&quot;性质2&quot;可知，高度为h的二叉树最多有2{h}–1个结点。反之，对于包含n个节点的二叉树的高度至少为log2(n+1)。</p><p><strong>2.4 性质4：在任意一棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则n0=n2+1</strong></p><p>证明：因为二叉树中所有结点的度数均不大于2，所以结点总数(记为n)=&quot;0度结点数(n0)&quot; + &quot;1度结点数(n1)&quot; + &quot;2度结点数(n2)&quot;。由此，得到等式一。 (等式一) n=n0+n1+n2 　 另一方面，0度结点没有孩子，1度结点有一个孩子，2度结点有两个孩子，故二叉树中孩子结点总数是：n1+2n2。此外，只有根不是任何结点的孩子。故二叉树中的结点总数又可表示为等式二。 (等式二) n=n1+2n2+1 由(等式一)和(等式二)计算得到：n0=n2+1。原命题得证！</p><h3 id="满二叉树" tabindex="-1"><a class="header-anchor" href="#满二叉树"><span><strong>满二叉树</strong></span></a></h3><p>叶子节点都在同一层并且除叶子节点外的所有节点都有两个子节点。</p><figure><img src="https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20210712153135194.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="完全二叉树" tabindex="-1"><a class="header-anchor" href="#完全二叉树"><span><strong>完全二叉树</strong></span></a></h3><p>对于一颗二叉树，假设其深度为d（d&gt;1）。除第d层外的所有节点构成满 二叉树，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；</p><figure><img src="https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20210712153143568.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li>叶子结点只能出现在最下两层。</li><li>最下层的叶子一定集中在左部连续位置。</li><li>倒数二层，若有叶子结点，一定都在右部连续位置。</li><li>如果结点度为1,则该结点只有左孩子，即不存在只有右子树的情况。</li><li>同样结点数的二叉树，完全二叉树的深度最小。</li></ol><h3 id="完全满二叉树" tabindex="-1"><a class="header-anchor" href="#完全满二叉树"><span><strong>完全满二叉树</strong></span></a></h3><figure><img src="https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20210712153156543.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20210712153212846.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="哈夫曼树" tabindex="-1"><a class="header-anchor" href="#哈夫曼树"><span><strong>哈夫曼树</strong></span></a></h3><p>带权路径最短的二叉树称为哈夫曼树或最优二叉树。</p><h3 id="二叉查找树" tabindex="-1"><a class="header-anchor" href="#二叉查找树"><span><strong>二叉查找树</strong></span></a></h3><p>（二叉搜索树、二叉排序树、BST）[这几个都是别名]</p><p>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</p><p>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</p><p>任意节点的左、右子树也分别为二叉查找树；``</p><p>没有键值相等的节点。</p><h3 id="线索二叉树" tabindex="-1"><a class="header-anchor" href="#线索二叉树"><span>线索二叉树</span></a></h3>',49),g={href:"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91/1602879",target:"_blank",rel:"noopener noreferrer"},v=n("h3",{id:"平衡二叉树",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#平衡二叉树"},[n("span",null,"平衡二叉树")])],-1),h=n("p",null,"它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树，同时，平衡二叉树必定是二叉搜索树。",-1),b=n("h3",{id:"avl树",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#avl树"},[n("span",null,"AVL树")])],-1),f=n("strong",null,"AVL树",-1),w=n("strong",null,"高度平衡树",-1),y={href:"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E6%A0%91%E6%97%8B%E8%BD%AC",target:"_blank",rel:"noopener noreferrer"},_=e('<p>AVL树本质上还是一棵二叉搜索树，它的特点是：</p><ol><li>本身首先是一棵二叉搜索树。</li><li>带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1。</li></ol><p>也就是说，AVL树，本质上是带了平衡功能的二叉查找树（二叉排序树，二叉搜索树）。</p><p><strong>使用场景：</strong></p><ul><li>AVL树适合用于插入删除次数比较少，但查找多的情况。</li><li>也在<code>Windows</code>进程地址空间管理中得到了使用</li><li>旋转的目的是为了降低树的高度，使其平衡</li></ul><h3 id="红黑树" tabindex="-1"><a class="header-anchor" href="#红黑树"><span><strong>红黑树</strong></span></a></h3><p>红黑树是每个节点都带有颜色属性的二叉查找树，颜色或红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:</p><ul><li>性质1. 节点是红色或黑色。</li><li>性质2. 根节点是黑色。</li><li>性质3. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li><li>性质4. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</li></ul><p><strong>使用场景：</strong></p><p>红黑树多用于搜索,插入,删除操作多的情况下红黑树应用比较广泛：</p><ul><li><p>广泛用在<code>C++</code>的<code>STL</code>中。<code>map</code>和<code>set</code>都是用红黑树实现的。</p></li><li><p>著名的<code>linux</code>进程调度<code>Completely Fair Scheduler</code>,用红黑树管理进程控制块。</p></li><li><p><code>epoll</code>在内核中的实现，用红黑树管理事件块</p></li><li><p><code>nginx</code>中，用红黑树管理<code>timer</code>等</p></li></ul><h3 id="伸展树" tabindex="-1"><a class="header-anchor" href="#伸展树"><span>伸展树</span></a></h3>',12),z={href:"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/10905079",target:"_blank",rel:"noopener noreferrer"},x=n("strong",null,"丹尼尔·斯立特",-1),E=n("strong",null,"罗伯特·恩卓·塔扬",-1),A=n("p",null,"Robert Endre Tarjan 在1985年发明的。",-1),B=n("p",null,"​ 在伸展树上的一般操作都基于伸展操作：假设想要对一个二叉查找树执行一系列的查找操作，为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。于是想到设计一个简单方法， 在每次查找之后对树进行重构，把被查找的条目搬移到离树根近一些的地方。伸展树应运而生。伸展树是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列的旋转把这个节点搬移到树根去。它的优势在于不需要记录用于平衡树的冗余信息。",-1),L=n("h3",{id:"替罪羊树",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#替罪羊树"},[n("span",null,"替罪羊树")])],-1),q={href:"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/9132",target:"_blank",rel:"noopener noreferrer"},T={href:"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6",target:"_blank",rel:"noopener noreferrer"},j={href:"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/O",target:"_blank",rel:"noopener noreferrer"},I={href:"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91",target:"_blank",rel:"noopener noreferrer"},P=e('<h3 id="b-tree-b-树或者b树" tabindex="-1"><a class="header-anchor" href="#b-tree-b-树或者b树"><span>B-tree（B-树或者B树）</span></a></h3><p>一棵m阶B树(balanced tree of order m)是一棵平衡的m路搜索树。它或者是空树，或者是满足下列性质的树：</p><ol><li>根结点至少有两个子女；</li><li>每个非根节点所包含的关键字个数 j 满足：┌m/2┐ - 1 &lt;= j &lt;= m - 1；</li><li>除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加1，故<strong>内部子树</strong>个数 k 满足：┌m/2┐ &lt;= k &lt;= m ；</li><li>所有的叶子结点都位于同一层。</li></ol><figure><img src="https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20210712153222564.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>B树(B-Tree)是一种自平衡的树,它是一种多路搜索树（并不是二叉的），能够保证数据有序。同时它还保证了在查找、插入、删除等操作时性能都能保持在<code>O(logn)</code>，为大块数据的读写操作做了优化,同时它也可以用来描述外部存储(支持对保存在磁盘或者网络上的符号表进行外部查找)</p><p><strong>B+树</strong></p><p>B+树是B树的一种变形形式，B+树上的叶子结点存储关键字以及相应记录的地址，叶子结点以上各层作为索引使用。一棵m阶的B+树定义如下:</p><ol><li>每个结点至多有m个子女；</li><li>除根结点外，每个结点至少有[m/2]个子女，根结点至少有两个子女；</li><li>有k个子女的结点必有k个关键字。</li></ol><p>B+树的查找与B树不同，当索引部分某个结点的关键字与所查的关键字相等时，并不停止查找，应继续沿着这个关键字左边的指针向下，一直查到该关键字所在的叶子结点为止。</p><p><strong>更适合文件索引系统</strong></p><p>原因： 增删文件（节点）时，效率更高，因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率</p><p><strong>使用场景：</strong></p><p>*文件系统和数据库系统中常用的B/B+ 树，他通过对每个节点存储个数的扩展，使得对连续的数据能够进行较快的定位和访问，能够有效减少查找时间，提高存</p><p><strong>储的空间局部性从而减少IO操作。他广泛用于文件系统及数据库中，如：</strong></p><ul><li>Windows：HPFS 文件系统</li><li>Mac：HFS，HFS+ 文件系统</li><li>Linux：ResiserFS，XFS，Ext3FS，JFS 文件系统</li><li>数据库：ORACLE，MYSQL，SQLSERVER 等中</li><li>B树：有序数组+平衡多叉树</li><li>B+树：有序数组链表+平衡多叉树</li></ul><p><strong>B树</strong></p><p>​ B<em>树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；B</em>树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）。</p><p>​ B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；</p><p>​ B树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；</p><p>所以，B树分配新结点的概率比B+树要低，空间使用率更高；</p><h3 id="字典树" tabindex="-1"><a class="header-anchor" href="#字典树"><span>字典树</span></a></h3>',21),N={href:"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/Trie%E6%A0%91",target:"_blank",rel:"noopener noreferrer"},S={href:"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84/9663807",target:"_blank",rel:"noopener noreferrer"},G={href:"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%AD%97%E7%AC%A6",target:"_blank",rel:"noopener noreferrer"},D=e(`<p>它有3个基本性质：</p><ol><li>根节点不包含字符，除根节点外每一个节点都只包含一个字符；</li><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串；</li><li>每个节点的所有子节点包含的字符都不相同。</li></ol><h2 id="二叉树遍历" tabindex="-1"><a class="header-anchor" href="#二叉树遍历"><span>二叉树遍历</span></a></h2><h3 id="前序遍历" tabindex="-1"><a class="header-anchor" href="#前序遍历"><span>前序遍历</span></a></h3><p><strong>第一次成为栈顶元素的时候</strong></p><p><code>根在前，从左往右，一棵树的根永远在左子树前面，左子树又永远在右子树前面(根左右) </code></p><p>前序遍历（DLR），是二叉树遍历的一种，也叫做先根遍历、先序遍历、前序周游，可记做根左右。前序遍历首先访问根结点然后遍历左子树，最后遍历右子树。</p><p>前序遍历首先访问根结点然后遍历左子树，最后遍历右子树。在遍历左、右子树时，仍然先访问根结点，然后遍历左子树，最后遍历右子树。</p><p>若二叉树为空则结束返回，否则：</p><p>（1）访问根结点</p><p>（2）前序遍历左子树</p><p>（3）前序遍历右子树</p><figure><img src="https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20210714090259980.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>需要注意的是：遍历左右子树时仍然采用前序遍历方法。</p><p>如右图所示二叉树</p><p>前序遍历结果：ABDECF</p><blockquote><p>递归</p></blockquote><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">perorder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">perorder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> node<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> res<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">perorder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">perorder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>迭代</p></blockquote><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
                root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            root <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="中序遍历" tabindex="-1"><a class="header-anchor" href="#中序遍历"><span>中序遍历</span></a></h3><p><strong>第二次成为栈顶元素的时候</strong></p><p><code>根在中，从左往右，一棵树的左子树永远在根前面，根永远在右子树前面(左根右)</code></p><p>中序遍历（LDR）是二叉树遍历的一种，也叫做中根遍历、中序周游。在二叉树中，中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。</p><p>中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。若二叉树为空则结束返回，否则：</p><p>（1）中序遍历左子树</p><p>（2）访问根结点</p><p>（3）中序遍历右子树</p><figure><img src="https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20210714090354411.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如右图所示二叉树，中序遍历结果：DBEAFC</p><blockquote><p>递归</p></blockquote><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">inorder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> node<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> res<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token function">inorder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">inorder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>迭代</p></blockquote><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
                root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            root <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
            root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="后序遍历" tabindex="-1"><a class="header-anchor" href="#后序遍历"><span>后序遍历</span></a></h3><p><strong>第三次成为栈顶元素的时候</strong></p><p><code>根在后，从左往右，一棵树的左子树永远在右子树前面，右子树永远在根前面(左右根)</code></p><p>后序遍历（LRD）是二叉树遍历的一种，也叫做后根遍历、后序周游，可记做左右根。后序遍历有递归算法和非递归算法两种。在二叉树中，先左后右再根，即首先遍历左子树，然后遍历右子树，最后访问根结点。</p><p>后序遍历首先遍历左子树，然后遍历右子树，最后访问根结点，在遍历左、右子树时，仍然先遍历左子树，然后遍历右子树，最后遍历根结点。即：</p><p>若二叉树为空则结束返回，</p><p>否则：</p><p>（1）后序遍历左子树</p><p>（2）后序遍历右子树</p><p>（3）访问根结点</p><figure><img src="https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20210714090627833.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如右图所示二叉树</p><p>后序遍历结果：DEBFCA</p><blockquote><p>递归</p></blockquote><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">postorder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postorder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> node<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> res<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token function">postorder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">postorder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>迭代</p></blockquote><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">TreeNode</span> prevNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
                root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            root <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> prevNode<span class="token punctuation">)</span><span class="token punctuation">{</span>
                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
                prevNode <span class="token operator">=</span> root<span class="token punctuation">;</span>
                root <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
                root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>已知前序遍历和中序遍历，就能确定后序遍历。</p><h3 id="层序遍历" tabindex="-1"><a class="header-anchor" href="#层序遍历"><span>层序遍历</span></a></h3><p>层序遍历，就是按层，从上到下，从左到右遍历</p><figure><img src="https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20210714090911846.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p>递归</p></blockquote><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>	

<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 用来存放最终结果</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> root<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 假设res是[ [1],[2,3] ]， index是3，就再插入一个空list放到res中</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 将当前节点的值加入到res中，index代表当前层，假设index是3，节点值是99</span>
        <span class="token comment">// res是[ [1],[2,3] [4] ]，加入后res就变为 [ [1],[2,3] [4,99] ]</span>
        res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 递归的处理左子树，右子树，同时将层数index+1</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">dfs</span><span class="token punctuation">(</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">dfs</span><span class="token punctuation">(</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="morris遍历" tabindex="-1"><a class="header-anchor" href="#morris遍历"><span>Morris遍历</span></a></h3><p>Morris遍历细节</p><p>假设来到当前节点cur，开始时cur来到头节点位置</p><ol><li>如果cur没有左孩子，cur向右移动(cur = cur.right)</li><li>如果cur有左孩子，找到左子树上最右的节点mostRight: <ul><li>如果mostRight的右指针指向空，让其指向cur,然后cur向左移动(cur = cur.left)</li><li>如果mostRight的右指针指向cur，让其指向null,然后cur向右移动(cur = cur.right)</li></ul></li><li>cur为空时遍历停止</li></ol><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><figure><img src="https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20210712153235112.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>`,63);function C(F,R){const a=o("ExternalLinkIcon");return c(),l("div",null,[u,n("p",null,[r,s("是一种"),n("a",k,[s("数据结构"),t(a)]),s("，它是由n（n>=1）个有限结点组成一个具有层次关系的"),n("a",d,[s("集合"),t(a)]),s("。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。")]),m,n("p",null,[s("​ 在"),n("a",g,[s("二叉树"),t(a)]),s("的结点上加上线索的二叉树称为线索二叉树，对二叉树以某种遍历方式（如先序、中序、后序或层次等）进行遍历，使其变为线索二叉树的过程称为对二叉树进行线索化。")]),v,h,b,n("p",null,[s("在计算机科学中，"),f,s("是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为"),w,s("。增加和删除可能需要通过一次或多次"),n("a",y,[s("树旋转"),t(a)]),s("来重新平衡这个树。")]),_,n("p",null,[s("​ 伸展树（Splay Tree），也叫分裂树，是一种"),n("a",z,[s("二叉排序树"),t(a)]),s("，它能在O(log n)内完成插入、查找和删除操作。它由"),x,s("Daniel Sleator 和 "),E]),A,B,L,n("p",null,[s("​ 替罪羊树是"),n("a",q,[s("计算机科学"),t(a)]),s("中，一种基于部分重建的自平衡二叉搜索树。在替罪羊树上，插入或删除节点的平摊最坏"),n("a",T,[s("时间复杂度"),t(a)]),s("是"),n("a",j,[s("O"),t(a)]),s("(log n)，搜索节点的最坏时间复杂度是O(log n)。")]),n("p",null,[s("​ 在非平衡的"),n("a",I,[s("二叉搜索树"),t(a)]),s("中，每次操作以后检查操作路径，找到最高的满足max(size(son_L),size(son_R))>alpha*size(this)的结点，重建整个子树。这样就得到了替罪羊树，而被重建的子树的原来的根就被称为替罪羊节点。替罪羊树替罪羊树是一棵自平衡二叉搜索树，由ArneAndersson提出。替罪羊树的主要思想就是将不平衡的树压成一个序列,然后暴力重构成一颗平衡的树。")]),P,n("p",null,[s("​ 又称单词查找树，"),n("a",N,[s("Trie树"),t(a)]),s("，是一种"),n("a",S,[s("树形结构"),t(a)]),s("，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的"),n("a",G,[s("字符"),t(a)]),s("串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。")]),D])}const M=p(i,[["render",C],["__file","tree.html.vue"]]),Z=JSON.parse('{"path":"/code/data-structure-and-algorithms/data-structure/tree.html","title":"树","lang":"zh-CN","frontmatter":{"order":4,"title":"树","date":"2020-12-29T00:00:00.000Z","category":"数据结构","tag":"数据结构","timeline":true,"article":true,"description":"树 树状图是一种数据结构，它是由n（n>=1）个有限结点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。 **它具有以下的特点：**每个结点有零个或多个子结点；没有父结点的结点称为根结点；每一个非根结点有且只有一个父结点；除了根结点外，每个子结点可以分为多个不相交的子树； 树结构是一种非线性存储结...","head":[["meta",{"property":"og:url","content":"https://du-mozzie.github.io/code/data-structure-and-algorithms/data-structure/tree.html"}],["meta",{"property":"og:title","content":"树"}],["meta",{"property":"og:description","content":"树 树状图是一种数据结构，它是由n（n>=1）个有限结点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。 **它具有以下的特点：**每个结点有零个或多个子结点；没有父结点的结点称为根结点；每一个非根结点有且只有一个父结点；除了根结点外，每个子结点可以分为多个不相交的子树； 树结构是一种非线性存储结..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20210712153740753.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-26T09:01:47.000Z"}],["meta",{"property":"article:author","content":"mozzie"}],["meta",{"property":"article:tag","content":"数据结构"}],["meta",{"property":"article:published_time","content":"2020-12-29T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-26T09:01:47.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"树\\",\\"image\\":[\\"https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20210712153740753.png\\",\\"https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20210712153135194.png\\",\\"https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20210712153143568.png\\",\\"https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20210712153156543.png\\",\\"https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20210712153212846.png\\",\\"https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20210712153222564.png\\",\\"https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20210714090259980.png\\",\\"https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20210714090354411.png\\",\\"https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20210714090627833.png\\",\\"https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20210714090911846.png\\",\\"https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20210712153235112.png\\"],\\"datePublished\\":\\"2020-12-29T00:00:00.000Z\\",\\"dateModified\\":\\"2024-05-26T09:01:47.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"mozzie\\",\\"url\\":\\"https://du-mozzie.github.io\\"}]}"]]},"headers":[{"level":2,"title":"术语","slug":"术语","link":"#术语","children":[]},{"level":2,"title":"树的种类","slug":"树的种类","link":"#树的种类","children":[{"level":3,"title":"无序树","slug":"无序树","link":"#无序树","children":[]},{"level":3,"title":"有序树","slug":"有序树","link":"#有序树","children":[]},{"level":3,"title":"二叉树","slug":"二叉树","link":"#二叉树","children":[]},{"level":3,"title":"满二叉树","slug":"满二叉树","link":"#满二叉树","children":[]},{"level":3,"title":"完全二叉树","slug":"完全二叉树","link":"#完全二叉树","children":[]},{"level":3,"title":"完全满二叉树","slug":"完全满二叉树","link":"#完全满二叉树","children":[]},{"level":3,"title":"哈夫曼树","slug":"哈夫曼树","link":"#哈夫曼树","children":[]},{"level":3,"title":"二叉查找树","slug":"二叉查找树","link":"#二叉查找树","children":[]},{"level":3,"title":"线索二叉树","slug":"线索二叉树","link":"#线索二叉树","children":[]},{"level":3,"title":"平衡二叉树","slug":"平衡二叉树","link":"#平衡二叉树","children":[]},{"level":3,"title":"AVL树","slug":"avl树","link":"#avl树","children":[]},{"level":3,"title":"红黑树","slug":"红黑树","link":"#红黑树","children":[]},{"level":3,"title":"伸展树","slug":"伸展树","link":"#伸展树","children":[]},{"level":3,"title":"替罪羊树","slug":"替罪羊树","link":"#替罪羊树","children":[]},{"level":3,"title":"B-tree（B-树或者B树）","slug":"b-tree-b-树或者b树","link":"#b-tree-b-树或者b树","children":[]},{"level":3,"title":"字典树","slug":"字典树","link":"#字典树","children":[]}]},{"level":2,"title":"二叉树遍历","slug":"二叉树遍历","link":"#二叉树遍历","children":[{"level":3,"title":"前序遍历","slug":"前序遍历","link":"#前序遍历","children":[]},{"level":3,"title":"中序遍历","slug":"中序遍历","link":"#中序遍历","children":[]},{"level":3,"title":"后序遍历","slug":"后序遍历","link":"#后序遍历","children":[]},{"level":3,"title":"层序遍历","slug":"层序遍历","link":"#层序遍历","children":[]},{"level":3,"title":"Morris遍历","slug":"morris遍历","link":"#morris遍历","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1716652325000,"updatedTime":1716714107000,"contributors":[{"name":"du","email":"25484255238@qq.com","commits":4}]},"readingTime":{"minutes":18.34,"words":5503},"filePathRelative":"code/data-structure-and-algorithms/data-structure/tree.md","localizedDate":"2020年12月29日","excerpt":"\\n<p><strong>树状图</strong>是一种<a href=\\"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">数据结构</a>，它是由n（n&gt;=1）个有限结点组成一个具有层次关系的<a href=\\"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E9%9B%86%E5%90%88\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">集合</a>。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</p>","autoDesc":true}');export{M as comp,Z as data};
