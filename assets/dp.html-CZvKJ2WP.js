import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,o as c,c as l,b as n,d as s,e,h as a}from"./app-PcV-7S7M.js";const i={},u=a(`<h1 id="动态规划-dp" tabindex="-1"><a class="header-anchor" href="#动态规划-dp"><span>动态规划(DP)</span></a></h1><h2 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念"><span>基本概念</span></a></h2><p>动态规划是对暴力递归算法的优化，主要是通过数组记录的方法，优化掉一些重复计算的过程。总结下动态规划的过程：</p><ol><li>抽象出一种“试法”，递归解决问题的方法，很重要</li><li>找到“试法”中的可变参数，规划成数组表，可变参数一般是0维的，有几个可变参数就是几维的表</li><li>找到base case，问题最基础的解，填入数组表中</li><li>根据“试法”中的递归过程，和base case已经填到数组表的值，继续填表</li><li>根据问题给定的参数，找到数组中对应的位置，就是最终的解</li></ol><h3 id="面试中设计暴力递归过程的原则" tabindex="-1"><a class="header-anchor" href="#面试中设计暴力递归过程的原则"><span>面试中设计暴力递归过程的原则</span></a></h3><blockquote><p>暴力递归和动态规划的关系</p></blockquote><ul><li>某一个暴力递归，有解的重复调用，就可以把这个暴力递归优化成动态规划</li><li>任何动态规划问题，都一定对应着某一个有重复过程的暴力递归，但不是所有的暴力递归，都一定对应着动态规划</li></ul><blockquote><p>原则</p></blockquote><ol><li>每一个可变参数的类型，一定不要比int类型更加复杂</li><li>原则1）可以违反，让类型突破到一维线性结构，那必须是单一可变参</li><li>如果发现原则1）被违反，但不违反原则2），只需要做到记忆化搜索即可</li><li>可变参数的个数，能少则少</li><li>递归函数的可变参数不能是数组类型，一个可变参数就是一维表，两个可变参数就是二维表。</li></ol><blockquote><p>如何找到某个问题的动态规划方式？</p></blockquote><ol><li>设计暴力递归：重要原则+4种常见尝试模型！重点！ <ul><li>从左往右的尝试模型</li><li>范围上的尝试模型</li><li>多样本位置全对应的尝试模型</li><li>寻找业务限制的尝试模型</li></ul></li><li>分析有没有重复解：套路解决</li><li>用记忆化搜索-&gt;用严格表结构实现动态规划：套路解决</li><li>看看能否继续优化：套路解决</li></ol><blockquote><p>暴力递归到动态规划的套路</p></blockquote><ol><li>你已经有了一个不违反原则的暴力递归，而且的确存在解的重复调用</li><li>找到哪些参数的变化会影响返回值，对每一个列出变化范围</li><li>参数间的所有的组合数量，意味着表大小</li><li>记忆化搜索的方法就是傻缓存，非常容易得到</li><li>规定好严格表的大小，分析位置的依赖顺序，然后从基础填写到最终解</li><li>对于有枚举行为的决策过程，进一步优化</li></ol><blockquote><p>记住求解的方式有两种</p></blockquote><ol><li>自顶向下的备忘录法</li><li>自底向上。</li></ol><p>在求解问题中,对于每一步决策,列出各种可能的局部解,再依据某种判定条件，舍弃那些肯定不能得到最优解的局部解,在每一步都经过筛选,以每一步都是最优解来保证全局是最优解。</p><blockquote><p>如何分析有没有重复解</p></blockquote><ol><li>列出调用过程，可以只列出前几层</li><li>有没有重复解，一看便知</li></ol><blockquote><p>动态规划的进一步优化</p></blockquote><ol><li>空间压缩</li><li>状态化简</li><li>四边形不等式</li><li>其他优化技巧</li></ol><p>滚动数组是DP中的一种编程思想。简单的理解就是让数组滚动起来，每次都使用固定的几个存储空间，来达到压缩，节省存储空间的作用。起到优化空间，主要应用在递推或动态规划中。因为DP题目是一个自底向上的扩展过程，我们常常需要用到的是连续的解，前面的解往往可以舍去。所以用滚动数组优化是很有效的。利用滚动数组的话在N很大的情况下可以达到压缩存储的作用。</p><p>知道了面试中设计暴力递归过程的原则，然后呢？一定要逼自己找到不违反原则情况下的暴力尝试！如果你找到的暴力尝试，不符合原则，马上舍弃！找新的！如果某个题目突破了设计原则，一定极难极难，面试中出现概率低于5%！</p><blockquote><p>暴力转成动态规划总结：</p></blockquote><ol><li>暴力递归的return值，dp也要进行赋值。</li><li>暴力的递归尝试改成从dp中取值。</li><li>递归参数是减，那么dp的for循环就是从小到大，从初始数据先写0也能看出来是从小到大循环</li><li>递归返回的参数是min。那么在递归中最上面min = Integer.MaxValue, 就需要给dp数组都赋值为此。而不是继续使用min</li><li>写递归方法时，判定停止条件可以是index == nums.length 也可以是index == nums.length - 1，这个停止条件适合那种小人移动问题，比如说一个m*n 数组最短路径，爬楼梯，打家劫舍；其余的都用index == nums.length</li></ol><p><strong>将一个问题拆成几个子问题，分别求解这些子问题，即可推断出大问题的解</strong></p><h3 id="常见的4种尝试模型" tabindex="-1"><a class="header-anchor" href="#常见的4种尝试模型"><span>常见的4种尝试模型</span></a></h3><h4 id="从左往右的尝试模型" tabindex="-1"><a class="header-anchor" href="#从左往右的尝试模型"><span>从左往右的尝试模型</span></a></h4><h4 id="范围上的尝试模型" tabindex="-1"><a class="header-anchor" href="#范围上的尝试模型"><span>范围上的尝试模型</span></a></h4><h4 id="多样本位置全对应的尝试模型" tabindex="-1"><a class="header-anchor" href="#多样本位置全对应的尝试模型"><span>多样本位置全对应的尝试模型</span></a></h4><h4 id="寻找业务限制的尝试模型" tabindex="-1"><a class="header-anchor" href="#寻找业务限制的尝试模型"><span>寻找业务限制的尝试模型</span></a></h4><h2 id="_01背包问题" tabindex="-1"><a class="header-anchor" href="#_01背包问题"><span>01背包问题</span></a></h2><p>有这么一个问题：有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><figure><img src="https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20241229195752657.png" alt="image-20241229195752657" tabindex="0" loading="lazy"><figcaption>image-20241229195752657</figcaption></figure><p>这个问题最先能够想到的就是暴力求解，每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是O(2<sup>n</sup>)，这里的n表示物品数量。</p><blockquote><p>暴力回溯</p></blockquote><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LeetCodeTest</span> <span class="token punctuation">{</span>
    
    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 物品的重量数组</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> weights <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token comment">// 物品的价值数组</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> values <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token comment">// 物品总数</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> values<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token comment">// 背包容量</span>
        <span class="token keyword">int</span> capacity <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>

        <span class="token comment">// 计算最大价值</span>
        <span class="token function">knapsack</span><span class="token punctuation">(</span>weights<span class="token punctuation">,</span> values<span class="token punctuation">,</span> n<span class="token punctuation">,</span> capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 输出最大价值</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;最大价值: &quot;</span> <span class="token operator">+</span> maxValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 记录当前背包中物品的最大价值</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> maxValue <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token comment">// 01背包的回溯方法</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">knapsack</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> weights<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> values<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 从第0个物品开始回溯</span>
        <span class="token function">backtrack</span><span class="token punctuation">(</span>weights<span class="token punctuation">,</span> values<span class="token punctuation">,</span> n<span class="token punctuation">,</span> capacity<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 回溯法递归函数</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> weights<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> values<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> capacity<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> currentValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果已经遍历完所有物品，更新最大价值</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            maxValue <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxValue<span class="token punctuation">,</span> currentValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 选择不放入当前物品</span>
        <span class="token function">backtrack</span><span class="token punctuation">(</span>weights<span class="token punctuation">,</span> values<span class="token punctuation">,</span> n<span class="token punctuation">,</span> capacity<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> currentValue<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 选择放入当前物品（前提是物品重量不超过背包剩余容量）</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>weights<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">backtrack</span><span class="token punctuation">(</span>weights<span class="token punctuation">,</span> values<span class="token punctuation">,</span> n<span class="token punctuation">,</span> capacity <span class="token operator">-</span> weights<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> currentValue <span class="token operator">+</span> values<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>可以使用一个二维表优化暴力回溯</p></blockquote><ol><li><p><strong>状态定义：</strong></p><ul><li>定义 <code>dp[i][j]</code> 表示在前 <code>i</code> 件物品中，背包容量为 <code>j</code> 时能取得的最大价值。</li><li><code>i</code> 表示考虑到第 <code>i</code> 个物品（包括不选和选它的两种情况）。</li><li><code>j</code> 表示背包的容量（从 <code>0</code> 到 <code>W</code>）。</li></ul></li><li><p><strong>状态转移方程：</strong></p><ul><li><p>对于第 <code>i</code> 个物品，我们有两个选择：</p><ul><li><strong>不选择第 <code>i</code> 个物品：</strong> <code>dp[i][j] = dp[i-1][j]</code>，即背包容量 <code>j</code> 下的最大价值不变。</li><li><strong>选择第 <code>i</code> 个物品：</strong> 如果物品的重量小于等于当前容量 <code>j</code>，则 <code>dp[i][j] = dp[i-1][j-weight[i]] + value[i]</code>，即加上第 <code>i</code> 个物品的价值。</li></ul></li><li><p>综合起来，状态转移方程为：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>dp[i][j] = max(dp[i-1][j], dp[i-1][j - weight[i]] + value[i])
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul></li><li><p><strong>初始化：</strong></p><ul><li><code>dp[0][j] = 0</code>，即没有物品时，背包中任何容量下的最大价值都为 0。</li><li><code>dp[i][0] = 0</code>，即背包容量为 0 时，任何物品都无法放入背包，最大价值为 0。</li></ul></li><li><p><strong>最终目标：</strong></p><ul><li>最终的答案是 <code>dp[n][W]</code>，即考虑所有物品并且背包容量为 <code>W</code> 时的最大价值。</li></ul></li></ol><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LeetCodeTest</span> <span class="token punctuation">{</span>
    
    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 物品的重量数组</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> weights <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token comment">// 物品的价值数组</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> values <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token comment">// 物品总数</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> values<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token comment">// 背包容量</span>
        <span class="token keyword">int</span> capacity <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>

        <span class="token comment">// 计算最大价值</span>
        <span class="token keyword">int</span> maxValue <span class="token operator">=</span> <span class="token function">knapsack</span><span class="token punctuation">(</span>weights<span class="token punctuation">,</span> values<span class="token punctuation">,</span> n<span class="token punctuation">,</span> capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 输出最大价值</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;最大价值: &quot;</span> <span class="token operator">+</span> maxValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 动态规划方法，计算最大价值</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">knapsack</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> weights<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> values<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建 DP 表，dp[i][j] 表示前 i 个物品，背包容量为 j 时的最大价值</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>capacity <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token comment">// 遍历每个物品</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> capacity<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 如果不选择第 i 个物品</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>

                <span class="token comment">// 如果选择第 i 个物品（且容量足够）</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>weights<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> weights<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> values<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 最终的最大价值存储在 dp[n][capacity] 中</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>时间和空间复杂度</p><ul><li><strong>时间复杂度：</strong> <code>O(n * W)</code>，其中 <code>n</code> 是物品的数量，<code>W</code> 是背包的容量。我们需要对每个物品和每个容量进行遍历。</li><li><strong>空间复杂度：</strong> <code>O(n * W)</code>，需要一个大小为 <code>n+1</code> x <code>W+1</code> 的二维数组来存储每个子问题的结果。</li></ul><blockquote><p>进一步优化</p></blockquote><p>我们可以发现，<strong>当前的状态只与前一行的状态有关</strong>，因此可以只使用一个一维数组来代替二维数组，从而节省空间。</p><ul><li>定义一个 <code>dp[j]</code> 数组，表示背包容量为 <code>j</code> 时的最大价值。</li><li>从 <code>i = 1</code> 到 <code>n</code> 遍历物品，在每次遍历物品时，从 <strong>背包容量从大到小</strong> 更新 <code>dp</code> 数组。这是因为我们要避免当前物品多次计算。</li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LeetCodeTest</span> <span class="token punctuation">{</span>
    
    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 物品的重量数组</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> weights <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token comment">// 物品的价值数组</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> values <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token comment">// 物品总数</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> values<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token comment">// 背包容量</span>
        <span class="token keyword">int</span> capacity <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>

        <span class="token comment">// 计算最大价值</span>
        <span class="token keyword">int</span> maxValue <span class="token operator">=</span> <span class="token function">knapsack</span><span class="token punctuation">(</span>weights<span class="token punctuation">,</span> values<span class="token punctuation">,</span> n<span class="token punctuation">,</span> capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 输出最大价值</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;最大价值: &quot;</span> <span class="token operator">+</span> maxValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 动态规划方法，计算最大价值</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">knapsack</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> weights<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> values<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// dp[i] 表示容量为 i 的背包所能获得的最大价值</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>capacity <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token comment">// 遍历每个物品</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 从后往前遍历，避免重复计算</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> capacity<span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> weights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> weights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 最终的最大价值存储在 dp[capacity] 中</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>时间复杂度和空间复杂度：</p><ul><li><strong>时间复杂度：</strong><code>O(n * W)</code>其中 <code>n</code> 是物品的数量，<code>W</code> 是背包的容量 <ul><li>外层循环遍历每个物品 <code>n</code> 次。</li><li>内层循环遍历每个可能的背包容量 <code>W</code> 次。</li></ul></li><li><strong>空间复杂度：</strong> <code>O(W)</code>，因为我们只需要一个一维数组来存储当前背包容量下的最大价值。</li></ul><p><strong>注意点</strong>：</p><ol><li>一定是先物品后背包；不然每个背包只装一个物品</li><li>背包一定是倒叙的，不然会重复装同一个</li></ol><h3 id="相关题目" tabindex="-1"><a class="header-anchor" href="#相关题目"><span>相关题目</span></a></h3>`,50),d=a("<li><p>纯01背包问题，容量为<code>i</code>最大能装多少价值的物品。</p><p>纯01背包问题是指每个物品只能被选择一次，且物品不能分割。容量为 <code>i</code> 的背包最大能装的价值可以通过动态规划解决。设 <code>dp[i]</code> 表示容量为 <code>i</code> 的背包能装的最大价值，则状态转移方程为： $$ dp[i] = max(dp[i], dp[i - w[j]] + v[j]) $$ 其中 <code>w[j]</code> 和 <code>v[j]</code> 分别为第 <code>j</code> 个物品的重量和价值。最终结果为 <code>dp[n]</code>，其中 <code>n</code> 为背包容量。</p></li>",1),k={href:"https://leetcode.cn/problems/partition-equal-subset-sum/description/",target:"_blank",rel:"noopener noreferrer"},r=n("code",null,"i",-1),m=a("<p>该问题是判断是否可以将一个数组分成两个子集，使得这两个子集的和相等。数组和为<code>sum</code>，背包容量为<code>target = sum / 2</code>，<code>target</code>如果是奇数则没有办法解决该问题，设 <code>dp[i]</code> 表示容量为<code>i</code> 的背包个能组成的最大价值，<code>dp[0]</code>的最大价值为0，则状态转移方程为： $$ dp[i] = max(dp[i], dp[i - num] + num) $$ 其中 <code>num</code> 为当前物品价值，同时也是物品的重量。如果 <code>dp[target] == target</code> 那么可以分割，否则不能。</p>",1),v={href:"https://leetcode.cn/problems/last-stone-weight-ii/description/",target:"_blank",rel:"noopener noreferrer"},b=n("code",null,"i",-1),h=a("<p>该问题是求在给定的石头数组中，每次可以选择任意两块石头，将它们同时粉碎，求所有石头都粉碎后，剩下的一块石头的重量，题可以将石头分为两个集合，数组和为<code>sum</code>，背包容量为<code>target = sum / 2</code>（向下取整，另外一个集合肯定比这个集合大）。这可以通过动态规划解决。设<code>dp[i]</code>表示容量为<code>i</code>的背包能组成的最大价值，<code>dp[0]</code>的最大价值为0，则状态转移方程为： $$ dp[i] = max(dp[i], dp[i - stone] + stone) $$ 其中 <code>stone</code> 为当前石头价值，同时也是石头的重量，<code>dp[target]</code>是其中一个集合，求差值就是结果<code>(sum - dp[target]) - dp[target]</code></p>",1),g={href:"https://leetcode.cn/problems/target-sum/description/",target:"_blank",rel:"noopener noreferrer"},y=n("code",null,"i",-1),w=a("<p>该问题是求给定一个整数数组<code>nums</code>和一个目标数<code>target</code>，求有多少种方法使得数组中某些数的和等于目标数，根据题意可以分为一个正数集合与一个负数集合，设数组和为<code>sum</code>，负数集合为<code>neg</code>，正数集合为<code>sum - neg</code>，则有如下公式： $$ (sum - neg) - neg = target\\ sum - 2neg = target\\ neg = (sum - target) / 2 $$ 通过上面公式可以得到背包容量<code>neg</code>，要求<code>neg</code>必须是非负偶数，因为要求数量和，设<code>dp[i]</code>表示容量为<code>i</code>时有几种方法能装满背包，<code>dp[0]</code>有一种方法，所以状态转移方程为： $$ dp[i] += dp[i - num] $$ 其中 <code>num</code> 为当前物品价值，同时也是物品的重量。最终结果为 <code>dp[target]</code>。</p>",1),f={href:"https://leetcode.cn/problems/ones-and-zeroes/",target:"_blank",rel:"noopener noreferrer"},_=n("code",null,"i",-1),x=a("<p>该问题是求给定一个由0和1组成的字符串数组，求在给定的0和1的容量限制下，最多可以装多少个字符串。字符串数组每一项都是一个物品，其0、1的数量就是对应价值与重量，背包有两个维度，设<code>dp[j][k]</code>表示<code>0</code>容量为<code>j</code>，<code>1</code>容量为<code>k</code>的时候能装的物品数量，状态转移方程为： $$ dp[j][k] = max(dp[j][k], dp[j - zero][k - one] + 1) $$ 其中 <code>zero</code> 和 <code>one</code> 分别为每个字符串中0和1的价值与重量。最终结果为 <code>dp[m][n]</code>，<code>m</code> 和 <code>n</code> 分别为0和1的容量限制。</p>",1),j=n("h2",{id:"树形dp套路",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#树形dp套路"},[n("span",null,"树形DP套路")])],-1),q=n("ol",null,[n("li",null,"以某个节点X为头节点的子树中，分析答案有哪些可能性，并且这种分析是以X的左子树、X的右子树和X整棵树的角度来考虑可能性的"),n("li",null,"根据第一步的可能性分析，列出所有需要的信息"),n("li",null,"合并第二步的信息，对左树和右树提出同样的要求，并写出信息结构"),n("li",null,"设计递归函数，递归函数是处理以X为头节点的情况下的答案。 包括设计递归的basecase，默认直接得到左树和右树的所有信息，以及把可能性做整合，并且要返回第三步的信息结构这四个小步骤")],-1),z=n("p",null,"一般都要用到查表",-1);function $(V,T){const t=o("ExternalLinkIcon");return c(),l("div",null,[u,n("ol",null,[d,n("li",null,[n("p",null,[n("a",k,[s("力扣 416.分割等和子集"),e(t)]),s("，容量为"),r,s("的背包能否装满指定价值的物品")]),m]),n("li",null,[n("p",null,[n("a",v,[s("力扣 1049.最后一块石头的重量Ⅱ"),e(t)]),s("，容量为"),b,s("的背包尽量装，最多能装多少")]),h]),n("li",null,[n("p",null,[n("a",g,[s("力扣 494.目标和"),e(t)]),s("，容量为"),y,s("的背包装满有几种方法")]),w]),n("li",null,[n("p",null,[n("a",f,[s("力扣 474.一和零"),e(t)]),s("，容量为"),_,s("的背包装满有多少物品")]),x])]),j,q,z])}const D=p(i,[["render",$],["__file","dp.html.vue"]]),N=JSON.parse('{"path":"/code/data-structure-and-algorithms/algorithms/dp.html","title":"动态规划","lang":"zh-CN","frontmatter":{"order":8,"title":"动态规划","date":"2021-01-07T00:00:00.000Z","category":"算法","tag":"算法","timeline":true,"article":true,"description":"动态规划(DP) 基本概念 动态规划是对暴力递归算法的优化，主要是通过数组记录的方法，优化掉一些重复计算的过程。总结下动态规划的过程： 抽象出一种“试法”，递归解决问题的方法，很重要 找到“试法”中的可变参数，规划成数组表，可变参数一般是0维的，有几个可变参数就是几维的表 找到base case，问题最基础的解，填入数组表中 根据“试法”中的递归过程，...","head":[["meta",{"property":"og:url","content":"https://du-mozzie.github.io/code/data-structure-and-algorithms/algorithms/dp.html"}],["meta",{"property":"og:title","content":"动态规划"}],["meta",{"property":"og:description","content":"动态规划(DP) 基本概念 动态规划是对暴力递归算法的优化，主要是通过数组记录的方法，优化掉一些重复计算的过程。总结下动态规划的过程： 抽象出一种“试法”，递归解决问题的方法，很重要 找到“试法”中的可变参数，规划成数组表，可变参数一般是0维的，有几个可变参数就是几维的表 找到base case，问题最基础的解，填入数组表中 根据“试法”中的递归过程，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20241229195752657.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-01-02T01:43:16.000Z"}],["meta",{"property":"article:author","content":"mozzie"}],["meta",{"property":"article:tag","content":"算法"}],["meta",{"property":"article:published_time","content":"2021-01-07T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-01-02T01:43:16.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"动态规划\\",\\"image\\":[\\"https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20241229195752657.png\\"],\\"datePublished\\":\\"2021-01-07T00:00:00.000Z\\",\\"dateModified\\":\\"2025-01-02T01:43:16.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"mozzie\\",\\"url\\":\\"https://du-mozzie.github.io\\"}]}"]]},"headers":[{"level":2,"title":"基本概念","slug":"基本概念","link":"#基本概念","children":[{"level":3,"title":"面试中设计暴力递归过程的原则","slug":"面试中设计暴力递归过程的原则","link":"#面试中设计暴力递归过程的原则","children":[]},{"level":3,"title":"常见的4种尝试模型","slug":"常见的4种尝试模型","link":"#常见的4种尝试模型","children":[]}]},{"level":2,"title":"01背包问题","slug":"_01背包问题","link":"#_01背包问题","children":[{"level":3,"title":"相关题目","slug":"相关题目","link":"#相关题目","children":[]}]},{"level":2,"title":"树形DP套路","slug":"树形dp套路","link":"#树形dp套路","children":[]}],"git":{"createdTime":1716652325000,"updatedTime":1735782196000,"contributors":[{"name":"mozzie","email":"du.mozzie@outlook.com","commits":4},{"name":"du","email":"25484255238@qq.com","commits":3}]},"readingTime":{"minutes":13.59,"words":4076},"filePathRelative":"code/data-structure-and-algorithms/algorithms/dp.md","localizedDate":"2021年1月7日","excerpt":"\\n<h2>基本概念</h2>","autoDesc":true}');export{D as comp,N as data};
