import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as n,h as i}from"./app-CsRjlK6S.js";const a={},o=i('<h1 id="时间复杂度、空间复杂度" tabindex="-1"><a class="header-anchor" href="#时间复杂度、空间复杂度"><span>时间复杂度、空间复杂度</span></a></h1><p>一个好的算法，满足以下两点：</p><ul><li><p>空间复杂度S(n)——算法写成的程序在执行时占用存储单元的长度。</p></li><li><p>时间复杂度T(n)——算法写成的程序在执行时耗费时间的长度。</p></li></ul><p>算法复杂度的渐进表示法：</p><ul><li><p>T(n)=O(f(n))表示存在常数C&gt;0，n<sub>0</sub>&gt;0使得当n≥n<sub>0</sub>时有T(n)≤C·f(n)</p></li><li><p>T(n)=Ω(g(n))表示存在常熟C&gt;0，n<sub>0</sub>&gt;0使得当n≥n<sub>0</sub>时有T(n)≥C·g(n)</p></li><li><p>T(n)=θ(h(n))表示同时有T(n)=O(h(n))和T(n)=Ω(h(n))</p></li></ul><figure><img src="https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20201207110034898.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20201207110228918.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20201207110457415.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p>复杂度分析小技巧</p></blockquote><p>若两段算法分别有复杂度T<sub>1</sub>(n)=O(f<sub>1</sub>(n))和T<sub>2</sub>(n)=O(f<sub>2</sub>(n))，则</p><ul><li>T<sub>1</sub>(n)+T<sub>2</sub>(n)=max(O(f<sub>1</sub>(n))，O(f<sub>2</sub>(n)))</li><li>T<sub>1</sub>(n)×T<sub>2</sub>(n)=O(f<sub>1</sub>(n)×f<sub>2</sub>(n))</li></ul><p>若T(n)是关于n的k阶多项式，那么T(n)=θ(n<sup>k</sup>)</p><p>一个<mark>for</mark>循环的时间复杂度等于循环次数乘以循环体代码的复杂度</p><p>​ <mark>if-else</mark>结构的复杂度取决于<mark>if</mark>的条件判断复杂度和两个分枝部分的复杂度，总体复杂度取三者中最大</p><p><strong>master公式：</strong></p><p><em>T</em>(<em>n</em>)=<em>a</em>∗<em>T</em>(<em>b/n</em>)+<em>n/d</em></p><p>T(n)：母问题 a：子问题被调用次数 <em>T</em>(<em>b/n</em>)：子问题的规模 n/d：剩下过程的时间复杂度</p><p>先确定abd</p><figure><img src="https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20220301201951903.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',19),r=[o];function m(s,p){return e(),n("div",null,r)}const g=t(a,[["render",m],["__file","complexity.html.vue"]]),l=JSON.parse('{"path":"/code/data-structure-and-algorithms/algorithms/complexity.html","title":"时间复杂度、空间复杂度","lang":"zh-CN","frontmatter":{"order":1,"title":"时间复杂度、空间复杂度","date":"2020-12-31T00:00:00.000Z","category":"算法","tag":"算法","timeline":true,"article":true,"prev":"./","description":"时间复杂度、空间复杂度 一个好的算法，满足以下两点： 空间复杂度S(n)——算法写成的程序在执行时占用存储单元的长度。 时间复杂度T(n)——算法写成的程序在执行时耗费时间的长度。 算法复杂度的渐进表示法： T(n)=O(f(n))表示存在常数C>0，n0>0使得当n≥n0时有T(n)≤C·f(n) T(n)=Ω(g(n))表示存在常熟C>0，n0>0...","head":[["meta",{"property":"og:url","content":"https://du-mozzie.github.io/code/data-structure-and-algorithms/algorithms/complexity.html"}],["meta",{"property":"og:title","content":"时间复杂度、空间复杂度"}],["meta",{"property":"og:description","content":"时间复杂度、空间复杂度 一个好的算法，满足以下两点： 空间复杂度S(n)——算法写成的程序在执行时占用存储单元的长度。 时间复杂度T(n)——算法写成的程序在执行时耗费时间的长度。 算法复杂度的渐进表示法： T(n)=O(f(n))表示存在常数C>0，n0>0使得当n≥n0时有T(n)≤C·f(n) T(n)=Ω(g(n))表示存在常熟C>0，n0>0..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20201207110034898.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-26T03:44:22.000Z"}],["meta",{"property":"article:author","content":"mozzie"}],["meta",{"property":"article:tag","content":"算法"}],["meta",{"property":"article:published_time","content":"2020-12-31T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-26T03:44:22.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"时间复杂度、空间复杂度\\",\\"image\\":[\\"https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20201207110034898.png\\",\\"https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20201207110228918.png\\",\\"https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20201207110457415.png\\",\\"https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20220301201951903.png\\"],\\"datePublished\\":\\"2020-12-31T00:00:00.000Z\\",\\"dateModified\\":\\"2024-05-26T03:44:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"mozzie\\",\\"url\\":\\"https://du-mozzie.github.io\\"}]}"]]},"headers":[],"git":{"createdTime":1716652325000,"updatedTime":1716695062000,"contributors":[{"name":"du","email":"25484255238@qq.com","commits":2}]},"readingTime":{"minutes":1.35,"words":404},"filePathRelative":"code/data-structure-and-algorithms/algorithms/complexity.md","localizedDate":"2020年12月31日","excerpt":"\\n<p>一个好的算法，满足以下两点：</p>","autoDesc":true}');export{g as comp,l as data};
