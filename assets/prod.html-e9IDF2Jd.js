import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as t,o,c as p,b as s,d as n,e as i,h as l}from"./app-BfXz85MS.js";const c={},r=l(`<p>工作中的一些ElasticSearch相关实践</p><h2 id="如何进行分片设置" tabindex="-1"><a class="header-anchor" href="#如何进行分片设置"><span>如何进行分片设置</span></a></h2><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token constant">PUT</span> <span class="token operator">/</span>my_index
<span class="token punctuation">{</span>
  <span class="token string">&quot;settings&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string">&quot;number_of_shards&quot;</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>         <span class="token comment">// 设置主分片数量为3</span>
    <span class="token string">&quot;number_of_replicas&quot;</span><span class="token operator">:</span> <span class="token number">1</span>        <span class="token comment">// 设置副本分片数量为1</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通常来说都需要为每个主分片设置一个副本分片</p><h2 id="集群监控" tabindex="-1"><a class="header-anchor" href="#集群监控"><span>集群监控</span></a></h2><p>Kibana</p><p>Grafana</p><h2 id="分页查询" tabindex="-1"><a class="header-anchor" href="#分页查询"><span>分页查询</span></a></h2><h3 id="_1-from-size方案" tabindex="-1"><a class="header-anchor" href="#_1-from-size方案"><span>1. from/size方案</span></a></h3><p>这是ES分页最常用的一种方案，跟mysql类似，from指定查询的起始位置，size表示从起始位置开始的文档数量</p><div class="language-json line-numbers-mode" data-ext="json" data-title="json"><pre class="language-json"><code>GET /kibana_sample_data_ecommerce/_search
<span class="token punctuation">{</span>
  <span class="token property">&quot;from&quot;</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> 
  <span class="token property">&quot;size&quot;</span> <span class="token operator">:</span> <span class="token number">10</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ES默认的分页深度是10000，from+size超过10000就会报错</p><div class="language-json line-numbers-mode" data-ext="json" data-title="json"><pre class="language-json"><code><span class="token punctuation">{</span>
	<span class="token property">&quot;error&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
		<span class="token property">&quot;root_cause&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>
			<span class="token property">&quot;type&quot;</span><span class="token operator">:</span> <span class="token string">&quot;illegal_argument_exception&quot;</span><span class="token punctuation">,</span>
			<span class="token property">&quot;reason&quot;</span><span class="token operator">:</span> <span class="token string">&quot;Result window is too large, from + size must be less than or equal to: [10000] but was [10009]. See the scroll api for a more efficient way to request large data sets. This limit can be set by changing the [index.max_result_window] index level setting.&quot;</span>
		<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
		<span class="token property">&quot;type&quot;</span><span class="token operator">:</span> <span class="token string">&quot;search_phase_execution_exception&quot;</span><span class="token punctuation">,</span>
		<span class="token property">&quot;reason&quot;</span><span class="token operator">:</span> <span class="token string">&quot;all shards failed&quot;</span><span class="token punctuation">,</span>
		<span class="token property">&quot;phase&quot;</span><span class="token operator">:</span> <span class="token string">&quot;query&quot;</span><span class="token punctuation">,</span>
		<span class="token property">&quot;grouped&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ES内部是通过<code>index.max_result_window</code>这个参数控制分页深度，ES之所以有这个限制，是因为在分布式环境下深度分页的查询效率会非常低。比如我们现在查询第from=990，size=10这样的条件，这个在业务层就是查询第990页，每页展示10条数据。</p><p>但是在ES处理的时候，会分别从每个分片上拿到1000条数据，然后在<code>coordinating</code>的节点上根据查询条件聚合出1000条记录，最后返回其中的10条。所以分页越深，ES处理的开销就大，占用内存就越大。</p><figure><img src="https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20240619154116466.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_2-search-after方案" tabindex="-1"><a class="header-anchor" href="#_2-search-after方案"><span>2. search after方案</span></a></h3><p>有时候我们会遇到一些业务场景，需要进行很深度的分页，但是可以不指定页数翻页，只要可以实时请求下一页就行。比如一些实时滚动的场景。</p><p>ES为这种场景提供了一种解决方案：search after。</p><p>search after利用实时有游标来帮我们解决实时滚动的问题，简单来说前一次查询的结果会返回一个唯一的字符串，下次查询带上这个字符串，进行<code>下一页</code>的查询。</p><div class="language-json line-numbers-mode" data-ext="json" data-title="json"><pre class="language-json"><code>GET /kibana_sample_data_ecommerce/_search
<span class="token punctuation">{</span>
  <span class="token property">&quot;size&quot;</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  <span class="token property">&quot;sort&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      <span class="token property">&quot;order_date&quot;</span><span class="token operator">:</span> <span class="token string">&quot;desc&quot;</span><span class="token punctuation">,</span>
      <span class="token property">&quot;_id&quot;</span><span class="token operator">:</span> <span class="token string">&quot;asc&quot;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先查询第一页数据，我这里指定取回2条，条件跟上一节一样。唯一的区别在于<code>sort</code>部分我多加了id，这个是为了在<code>order_date</code>字段一样的情况下告诉ES一个可选的排序方案。因为search after的游标是基于排序产生的。</p><p>查询结果会返回一个<code>sort</code>字段</p><div class="language-json line-numbers-mode" data-ext="json" data-title="json"><pre class="language-json"><code><span class="token property">&quot;sort&quot;</span> <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1580597280000</span><span class="token punctuation">,</span><span class="token string">&quot;RZz1f28BdseAsPClqbyw&quot;</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在下一页查询中带上这个sort</p><div class="language-json line-numbers-mode" data-ext="json" data-title="json"><pre class="language-json"><code>GET /kibana_sample_data_ecommerce/_search
<span class="token punctuation">{</span>
  <span class="token property">&quot;size&quot;</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  <span class="token property">&quot;search_after&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1580597280000</span><span class="token punctuation">,</span> <span class="token string">&quot;RZz1f28BdseAsPClqbyw&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token property">&quot;sort&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      <span class="token property">&quot;order_date&quot;</span><span class="token operator">:</span> <span class="token string">&quot;desc&quot;</span><span class="token punctuation">,</span>
      <span class="token property">&quot;_id&quot;</span><span class="token operator">:</span> <span class="token string">&quot;asc&quot;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>就这样一直操作就可以实现不断的查看下一页了。</p><p>因为有了排序的唯一标识，ES只需从每个分片上拿到满足条件的10条文档，然后基于这30条文档最终聚合成10条结果返回即可。</p><figure><img src="https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20240619154857865.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_3-scroll-api方案" tabindex="-1"><a class="header-anchor" href="#_3-scroll-api方案"><span>3. scroll api方案</span></a></h3><p>我们需要一次性或者每次查询大量的文档，但是对实时性要求并不高。ES针对这种场景提供了scroll api的方案。这个方案牺牲了实时性，但是查询效率确实非常高。</p><div class="language-json line-numbers-mode" data-ext="json" data-title="json"><pre class="language-json"><code>POST /kibana_sample_data_ecommerce/_search?scroll=1m
<span class="token punctuation">{</span>
    <span class="token property">&quot;size&quot;</span><span class="token operator">:</span> <span class="token number">10</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先我们第一次查询，会生成一个当前查询条件结果的快照，后面的每次滚屏（或者叫翻页）都是基于这个快照的结果，也就是即使有新的数据进来也不会别查询到。</p><p>上面这个查询结果会返回一个<code>scroll_id</code>，拷贝过来，组成下一条查询语句，</p><div class="language-json line-numbers-mode" data-ext="json" data-title="json"><pre class="language-json"><code>POST /_search/scroll
<span class="token punctuation">{</span>
    <span class="token property">&quot;scroll&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;1m&quot;</span><span class="token punctuation">,</span>
  	<span class="token property">&quot;scroll_id&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;FGluY2x1ZGVfY29udGV4dF91dWlkDnF1ZXJ5VGhlbkZldGNoAxRNOVI1TDVBQjQwNXNWamdheDhsbQAAAAAG3LpoFklpZjM3MTVVU1BhbjhJdmJyZzJZOFEUTkZGNUw1QUJlMG5tSHVMeHg5YUEAAAAABt5pNRZOaEdXV3JpUVFXLTh4U0ZNME1IdUN3FDFLZDVMNUFCeTAtcTc2SFd4Njk0AAAAAAbQiZUWQ1J1VllmOVhRcmVSTzFqcVpCeWtBZw&quot;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以此类推，后面每次滚屏都把前一个的<code>scroll_id</code>复制过来。注意到，后续请求时没有了index信息，size信息等，这些都在初始请求中，只需要使用scroll_id和scroll两个参数即可。</p><p>很多人对<code>scroll</code>这个参数容易混淆，误认为是查询的限制时间。这个理解是错误的。这个时间其实指的是es把本次快照的结果缓存起来的有效时间。</p><p>scroll 参数相当于告诉了 ES我们的<code>search context</code>要保持多久，后面每个 scroll 请求都会设置一个新的过期时间，以确保我们可以一直进行下一页操作。</p><p>我们继续讨论一个问题，<code>scroll</code>这种方式为什么会比较高效？</p><p>ES的检索分为查询（query）和获取（fetch）两个阶段，query阶段比较高效，只是查询满足条件的文档id汇总起来。fetch阶段则基于每个分片的结果在coordinating节点上进行全局排序，然后最终计算出结果。</p><p>scroll查询的时候，在query阶段把符合条件的文档id保存在前面提到的<code>search context</code>里。后面每次scroll分批取回只是根据scroll_id定位到游标的位置，然后抓取size大小的结果集即可。</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3>`,42),d=s("li",null,"from/size方案的优点是简单，缺点是在深度分页的场景下系统开销比较大，占用较多内存。",-1),u=s("li",null,[n("search after基于ES内部排序好的游标，可以实时高效的进行分页查询，但是它只能做"),s("code",null,"下一页"),n("这样的查询场景，不能随机的指定页数查询。")],-1),m={href:"https://cloud.tencent.com/product/bi?from_column=20065&from=20065",target:"_blank",rel:"noopener noreferrer"};function v(k,h){const a=t("ExternalLinkIcon");return o(),p("div",null,[r,s("ul",null,[d,u,s("li",null,[n("scroll方案也很高效，但是它基于快照，不能用在实时性高的业务场景，建议用在类似"),s("a",m,[n("报表"),i(a)]),n("导出，或者ES内部的reindex等场景。")])])])}const q=e(c,[["render",v],["__file","prod.html.vue"]]),_=JSON.parse('{"path":"/code/distributed/elasticsearch/prod.html","title":"生产实践","lang":"zh-CN","frontmatter":{"order":5,"title":"生产实践","date":"2023-08-11T00:00:00.000Z","category":["ElasticSearch","分布式","搜索引擎"],"tag":["ElasticSearch","分布式","搜索引擎"],"timeline":true,"article":true,"description":"工作中的一些ElasticSearch相关实践 如何进行分片设置 通常来说都需要为每个主分片设置一个副本分片 集群监控 Kibana Grafana 分页查询 1. from/size方案 这是ES分页最常用的一种方案，跟mysql类似，from指定查询的起始位置，size表示从起始位置开始的文档数量 ES默认的分页深度是10000，from+size...","head":[["meta",{"property":"og:url","content":"https://du-mozzie.github.io/code/distributed/elasticsearch/prod.html"}],["meta",{"property":"og:title","content":"生产实践"}],["meta",{"property":"og:description","content":"工作中的一些ElasticSearch相关实践 如何进行分片设置 通常来说都需要为每个主分片设置一个副本分片 集群监控 Kibana Grafana 分页查询 1. from/size方案 这是ES分页最常用的一种方案，跟mysql类似，from指定查询的起始位置，size表示从起始位置开始的文档数量 ES默认的分页深度是10000，from+size..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20240619154116466.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-20T03:00:38.000Z"}],["meta",{"property":"article:author","content":"mozzie"}],["meta",{"property":"article:tag","content":"ElasticSearch"}],["meta",{"property":"article:tag","content":"分布式"}],["meta",{"property":"article:tag","content":"搜索引擎"}],["meta",{"property":"article:published_time","content":"2023-08-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-20T03:00:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"生产实践\\",\\"image\\":[\\"https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20240619154116466.png\\",\\"https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20240619154857865.png\\"],\\"datePublished\\":\\"2023-08-11T00:00:00.000Z\\",\\"dateModified\\":\\"2024-06-20T03:00:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"mozzie\\",\\"url\\":\\"https://du-mozzie.github.io\\"}]}"]]},"headers":[{"level":2,"title":"如何进行分片设置","slug":"如何进行分片设置","link":"#如何进行分片设置","children":[]},{"level":2,"title":"集群监控","slug":"集群监控","link":"#集群监控","children":[]},{"level":2,"title":"分页查询","slug":"分页查询","link":"#分页查询","children":[{"level":3,"title":"1. from/size方案","slug":"_1-from-size方案","link":"#_1-from-size方案","children":[]},{"level":3,"title":"2. search after方案","slug":"_2-search-after方案","link":"#_2-search-after方案","children":[]},{"level":3,"title":"3. scroll api方案","slug":"_3-scroll-api方案","link":"#_3-scroll-api方案","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]}],"git":{"createdTime":1718249717000,"updatedTime":1718852438000,"contributors":[{"name":"du","email":"25484255238@qq.com","commits":3}]},"readingTime":{"minutes":4.75,"words":1426},"filePathRelative":"code/distributed/elasticsearch/prod.md","localizedDate":"2023年8月11日","excerpt":"<p>工作中的一些ElasticSearch相关实践</p>","autoDesc":true}');export{q as comp,_ as data};
