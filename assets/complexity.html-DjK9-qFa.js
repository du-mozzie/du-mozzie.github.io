import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as e,h as o}from"./app-HscYGYLB.js";const a="/assets/image-20201207110034898-BMzTg5TM.png",s="/assets/image-20201207110228918-BN53DOKz.png",i="/assets/image-20201207110457415-CqoqRr5o.png",p="/assets/image-20220301201951903-Csk00PFm.png",r={},c=o('<h1 id="时间复杂度、空间复杂度" tabindex="-1"><a class="header-anchor" href="#时间复杂度、空间复杂度"><span>时间复杂度、空间复杂度</span></a></h1><blockquote><p>一个好的算法，满足以下两点</p></blockquote><p>空间复杂度S(n)——算法写成的程序在执行时占用存储单元的长度。</p><p>时间复杂度T(n)——算法写成的程序在执行时耗费时间的长度。</p><blockquote><p>算法复杂度的渐进表示法</p></blockquote><p>T(n)=O(f(n))表示存在常数C&gt;0，n<sub>0</sub>&gt;0使得当n≥n<sub>0</sub>时有T(n)≤C·f(n)</p><p>T(n)=Ω(g(n))表示存在常熟C&gt;0，n<sub>0</sub>&gt;0使得当n≥n<sub>0</sub>时有T(n)≥C·g(n)</p><p>T(n)=θ(h(n))表示同时有T(n)=O(h(n))和T(n)=Ω(h(n))</p><figure><img src="'+a+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+s+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+i+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p>复杂度分析小技巧</p></blockquote><p>若两段算法分别有复杂度T<sub>1</sub>(n)=O(f<sub>1</sub>(n))和T<sub>2</sub>(n)=O(f<sub>2</sub>(n))，则</p><ul><li>T<sub>1</sub>(n)+T<sub>2</sub>(n)=max(O(f<sub>1</sub>(n))，O(f<sub>2</sub>(n)))</li><li>T<sub>1</sub>(n)×T<sub>2</sub>(n)=O(f<sub>1</sub>(n)×f<sub>2</sub>(n))</li></ul><p>若T(n)是关于n的k阶多项式，那么T(n)=θ(n<sup>k</sup>)</p><p>一个<mark>for</mark>循环的时间复杂度等于循环次数乘以循环体代码的复杂度</p><p>​ <mark>if-else</mark>结构的复杂度取决于<mark>if</mark>的条件判断复杂度和两个分枝部分的复杂度，总体复杂度取三者中最大</p><p><strong>master公式：</strong></p><p><em>T</em>(<em>n</em>)=<em>a</em>∗<em>T</em>(<em>b/n</em>)+<em>n/d</em></p><p>T(n)：母问题 a：子问题被调用次数 <em>T</em>(<em>b/n</em>)：子问题的规模 n/d：剩下过程的时间复杂度</p><p>先确定abd</p><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',22),m=[c];function u(l,g){return t(),e("div",null,m)}const f=n(r,[["render",u],["__file","complexity.html.vue"]]),T=JSON.parse('{"path":"/code/data-structure-and-algorithms/algorithms/complexity.html","title":"时间复杂度、空间复杂度","lang":"zh-CN","frontmatter":{"order":1,"title":"时间复杂度、空间复杂度","date":"2020-12-31T00:00:00.000Z","category":"数据结构与算法","timeline":true,"article":false,"prev":".../","description":"时间复杂度、空间复杂度 一个好的算法，满足以下两点 空间复杂度S(n)——算法写成的程序在执行时占用存储单元的长度。 时间复杂度T(n)——算法写成的程序在执行时耗费时间的长度。 算法复杂度的渐进表示法 T(n)=O(f(n))表示存在常数C>0，n0>0使得当n≥n0时有T(n)≤C·f(n) T(n)=Ω(g(n))表示存在常熟C>0，n0>0使得...","head":[["meta",{"property":"og:url","content":"https://du-mozzie.github.io/code/data-structure-and-algorithms/algorithms/complexity.html"}],["meta",{"property":"og:title","content":"时间复杂度、空间复杂度"}],["meta",{"property":"og:description","content":"时间复杂度、空间复杂度 一个好的算法，满足以下两点 空间复杂度S(n)——算法写成的程序在执行时占用存储单元的长度。 时间复杂度T(n)——算法写成的程序在执行时耗费时间的长度。 算法复杂度的渐进表示法 T(n)=O(f(n))表示存在常数C>0，n0>0使得当n≥n0时有T(n)≤C·f(n) T(n)=Ω(g(n))表示存在常熟C>0，n0>0使得..."}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-08T03:48:18.000Z"}],["meta",{"property":"article:author","content":"Du"}],["meta",{"property":"article:published_time","content":"2020-12-31T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-08T03:48:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"时间复杂度、空间复杂度\\",\\"description\\":\\"时间复杂度、空间复杂度 一个好的算法，满足以下两点 空间复杂度S(n)——算法写成的程序在执行时占用存储单元的长度。 时间复杂度T(n)——算法写成的程序在执行时耗费时间的长度。 算法复杂度的渐进表示法 T(n)=O(f(n))表示存在常数C>0，n0>0使得当n≥n0时有T(n)≤C·f(n) T(n)=Ω(g(n))表示存在常熟C>0，n0>0使得...\\"}"]]},"headers":[],"git":{"createdTime":1715140098000,"updatedTime":1715140098000,"contributors":[{"name":"du","email":"25484255238@qq.com","commits":1}]},"readingTime":{"minutes":1.33,"words":398},"filePathRelative":"code/data-structure-and-algorithms/algorithms/complexity.md","localizedDate":"2020年12月31日","excerpt":"\\n<blockquote>\\n<p>一个好的算法，满足以下两点</p>\\n</blockquote>\\n<p>空间复杂度S(n)——算法写成的程序在执行时占用存储单元的长度。</p>\\n<p>时间复杂度T(n)——算法写成的程序在执行时耗费时间的长度。</p>\\n<blockquote>\\n<p>算法复杂度的渐进表示法</p>\\n</blockquote>\\n<p>T(n)=O(f(n))表示存在常数C&gt;0，n<sub>0</sub>&gt;0使得当n≥n<sub>0</sub>时有T(n)≤C·f(n)</p>\\n<p>T(n)=Ω(g(n))表示存在常熟C&gt;0，n<sub>0</sub>&gt;0使得当n≥n<sub>0</sub>时有T(n)≥C·g(n)</p>","autoDesc":true}');export{f as comp,T as data};
