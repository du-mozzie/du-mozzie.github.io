import{_ as r}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as i,o as n,c,b as e,d as t,e as o,h as s}from"./app-nopQRHQp.js";const p={},u=s('<h1 id="栈和队列" tabindex="-1"><a class="header-anchor" href="#栈和队列"><span>栈和队列</span></a></h1><p>栈和队列，也属于线性表，因为它们也都用于存储逻辑关系为 &quot;一对一&quot; 的数据。使用栈结构存储数据，讲究先进后出，即最先进栈的数据，最后出栈；使用队列存储数据，讲究先进先出，即最先进队列的数据，也最先出队列。</p><figure><img src="https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20210513125707472.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>push：插入</p><p>pop：删除</p><p>peek：查看顶部</p><h2 id="栈-stack" tabindex="-1"><a class="header-anchor" href="#栈-stack"><span>栈(stack)</span></a></h2><p><mark>栈是限定仅在表尾进行插入和删除的线性表</mark></p><p>允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈。</p><p>后进先出LIFO</p><blockquote><p>栈的插入操作，叫作进栈，也称压栈、入栈。</p><p>栈的删除操作，叫作出栈，有的也叫作弹栈。</p></blockquote><figure><img src="https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20210419215326952.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>逆波兰，使用栈结构来帮助计算机处理数学加减乘除计算问题</strong></p><p>​ 把生活中数学中缀表示法改成后缀表示法</p><p>​ 逆波兰记法中，操作符置于操作数的后面。例如表达“三加四”时，写作“3 4 + ”，而不是“3 + 4”。如果有多个操作符，操作符置于第二个操作数的后面，所以常规中缀记法的“3 - 4 + 5”在逆波兰记法中写作“3 4 - 5 + ”：先3减去4，再加上5。使用逆波兰记法的一个好处是不需要使用括号。例如中缀记法中“3 - 4 * 5”与“（3 - 4）*5”不相同，但后缀记法中前者写做“3 4 5 * - ”，无歧义地表示“3 (4 5 *) -”；后者写做“3 4 - 5 * ”。</p>',15),l={href:"https://zh.wikipedia.org/wiki/%E8%A7%A3%E9%87%8A%E5%99%A8",target:"_blank",rel:"noopener noreferrer"},d={href:"https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88",target:"_blank",rel:"noopener noreferrer"},m=e("h2",{id:"队列-queue",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#队列-queue"},[e("span",null,"队列(Queue)")])],-1),h=e("p",null,[e("mark",null,"队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表")],-1),g=e("p",null,"先进先出FIFO",-1),_=e("blockquote",null,[e("p",null,"循环队列、双端队列Deque")],-1),k=e("p",null,"支持两端元素插入和移除的线性集合，头尾相接的顺序存储结构，插入删除不需要申请和释放节点，扩充空间较为麻烦",-1),f=e("blockquote",null,[e("p",null,"链队列")],-1),z=e("p",null,"使用链式结构存储元素，有指针，插入删除需要申请和释放节点，扩充空间较为简便",-1);function b(y,q){const a=i("ExternalLinkIcon");return n(),c("div",null,[u,e("p",null,[t("逆波兰表达式的"),e("a",l,[t("解释器"),o(a)]),t("一般是基于"),e("a",d,[t("堆栈"),o(a)]),t("的。解释过程一般是：操作数入栈；遇到操作符时，操作数出栈，求值，将结果入栈；当一遍后，栈顶就是表达式的值。因此逆波兰表达式的求值使用堆栈结构很容易实现，并且能很快求值。")]),m,h,g,_,k,f,z])}const T=r(p,[["render",b],["__file","stackQueue.html.vue"]]),E=JSON.parse('{"path":"/code/data-structure-and-algorithms/data-structure/stackQueue.html","title":"栈和队列","lang":"zh-CN","frontmatter":{"order":2,"title":"栈和队列","date":"2020-12-27T00:00:00.000Z","category":"数据结构","tag":"数据结构","timeline":true,"article":true,"description":"栈和队列 栈和队列，也属于线性表，因为它们也都用于存储逻辑关系为 \\"一对一\\" 的数据。使用栈结构存储数据，讲究先进后出，即最先进栈的数据，最后出栈；使用队列存储数据，讲究先进先出，即最先进队列的数据，也最先出队列。 push：插入 pop：删除 peek：查看顶部 栈(stack) 栈是限定仅在表尾进行插入和删除的线性表 允许插入和删除的一端称为栈顶，...","head":[["meta",{"property":"og:url","content":"https://du-mozzie.github.io/code/data-structure-and-algorithms/data-structure/stackQueue.html"}],["meta",{"property":"og:title","content":"栈和队列"}],["meta",{"property":"og:description","content":"栈和队列 栈和队列，也属于线性表，因为它们也都用于存储逻辑关系为 \\"一对一\\" 的数据。使用栈结构存储数据，讲究先进后出，即最先进栈的数据，最后出栈；使用队列存储数据，讲究先进先出，即最先进队列的数据，也最先出队列。 push：插入 pop：删除 peek：查看顶部 栈(stack) 栈是限定仅在表尾进行插入和删除的线性表 允许插入和删除的一端称为栈顶，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20210513125707472.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-26T03:44:22.000Z"}],["meta",{"property":"article:author","content":"mozzie"}],["meta",{"property":"article:tag","content":"数据结构"}],["meta",{"property":"article:published_time","content":"2020-12-27T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-26T03:44:22.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"栈和队列\\",\\"image\\":[\\"https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20210513125707472.png\\",\\"https://raw.githubusercontent.com/du-mozzie/PicGo/master/images/image-20210419215326952.png\\"],\\"datePublished\\":\\"2020-12-27T00:00:00.000Z\\",\\"dateModified\\":\\"2024-05-26T03:44:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"mozzie\\",\\"url\\":\\"https://du-mozzie.github.io\\"}]}"]]},"headers":[{"level":2,"title":"栈(stack)","slug":"栈-stack","link":"#栈-stack","children":[]},{"level":2,"title":"队列(Queue)","slug":"队列-queue","link":"#队列-queue","children":[]}],"git":{"createdTime":1716652325000,"updatedTime":1716695062000,"contributors":[{"name":"du","email":"25484255238@qq.com","commits":2}]},"readingTime":{"minutes":2.2,"words":660},"filePathRelative":"code/data-structure-and-algorithms/data-structure/stackQueue.md","localizedDate":"2020年12月27日","excerpt":"\\n<p>栈和队列，也属于线性表，因为它们也都用于存储逻辑关系为 \\"一对一\\" 的数据。使用栈结构存储数据，讲究先进后出，即最先进栈的数据，最后出栈；使用队列存储数据，讲究先进先出，即最先进队列的数据，也最先出队列。</p>","autoDesc":true}');export{T as comp,E as data};
