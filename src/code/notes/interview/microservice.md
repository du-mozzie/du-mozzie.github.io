---
order: 2
title: 微服务相关的面试
date: 2026-02-17
category: 
    - 面试
    - 微服务
tag: 
    - 面试
    - 微服务
timeline: true
article: true
prev: ./
---

微服务相关的面试技巧

## 服务注册与发现

````markmap
---
markmap:
  colorFreezeLevel: 3
---

# 服务注册与发现

## 基本模型：三角形

### 服务上线
#### 1. 服务端启动成功，注册自身信息
#### 2. 注册中心和服务端要保持心跳
   - 注册中心通过心跳判断服务端是否崩溃
#### 3. 客户端找注册中心查询可用服务节点列表，缓存到本地
   - 可引导到缓存一致性
#### 4. 客户端和注册中心要保持心跳和数据同步
#### 5. 客户端发送请求
#### 6. 服务端返回响应

### 服务下线(引导到微服务优雅退出)
#### 1. 服务端通知注册中心自己准备下线
 - 1、2、3 需要的时间就是服务端等待的最短时间
#### 2. 注册中心通知客户端服务端下线
#### 3. 客户端不再使用该服务端
#### 4. 服务端等待一段时间之后，下线

## 高可用

### 服务端崩溃检测(总结心跳的一般机制)
- 心跳不通，立刻通知客户端
- 继续保持心跳
- 心跳如果一直失败，那么认为节点崩溃
- 心跳如果恢复，就通知客户端该节点可以继续使用


### 客户端容错

#### 原因
- 服务端崩溃
- 客户端和服务端网络不通
- 客户端连不上注册中心：客户端一直拿着老的可用节点列表

#### 措施
- 客户端发送请求失败，将节点踢出可用列表

- 和服务端崩溃检测心跳机制类似
  - 客户端继续给该节点发送心跳
  - 如果心跳重试都失败了，节点彻底不可用
  - 如果心跳恢复，客户端将节点放回可用列表


### 注册中心选型

#### 常见因素
- 中间件成熟度
- 社区活跃度
- 性能

#### CAP
- 数据一致性（C）服务可用性（A）分区容错性（P）
- CP 和 AP 选 AP
````

## 负载均衡

````markmap
---
markmap:
  colorFreezeLevel: 3
---

# 微服务负载均衡

## 基本算法

### 轮询与加权轮询
- 设置权重
  - 处理器的处理能力
  - 节点的重要性 / 优先级
  - 节点所在位置
- 平滑的加权轮询算法
  - Nginx 采用该算法

### 随机与加权随机

### 哈希与一致性哈希
- 哈希值均匀性
- 一致性哈希
  - Redis Cluster

### 最少连接数
- 多路复用的问题, 话题可以引向 IO 模型

### 最少活跃数

### 最快响应时间
#### 响应时间选取
- 平均值
- 99 线
- 999 线
- 中位数

#### 响应时间衰减
- 所有采集到的指标都需要考虑衰减问题

### 所有算法的固有缺陷
- 没有考虑请求所需资源不同，导致偶发性负载不均衡
- 没有真正计算服务端的负载，动态算法算了但不够准确

## 亮点

### 调用结果对负载均衡的影响
#### 动态调整权重
- 设置上下限
- 错误调整引发线上事故

#### 客户端上采用的服务治理措施,可以利用调用结果来调整

### 一致性哈希算法与本地缓存
- 提供缓存命中率
- 减少内存使用
- 依旧有不一致的问题
  - 缓存与数据一致性话题
  - 服务扩容的例子
````

## 熔断

````markmap
---
markmap:
  colorFreezeLevel: 3
---

# 微服务熔断

## 基本概念

### 判定节点健康状态(综合考虑负载均衡、限流、降级)

#### 指标
##### 服务指标
- 响应时间（常用指标）
- 错误率

##### 硬件指标
- CPU
- 内存
- 网络 IO
- 磁盘 IO

##### 第三方依赖
- 业务的核心依赖崩溃即可触发熔断

#### 持续时间
- 避开偶发性异常
- 过长则未能及时熔断
- 过短容易引起抖动

### 如何恢复
- 等待一段时间
- 逐步放开流量，类似于灰度发布

### 抖动
- 与前两个因素有关

## 亮点方案

### 结合负载均衡

### 步骤
1. 服务端返回熔断响应
2. 客户端将服务端节点踢出可用节点列表
3. 客户端等待一段时间
4. 客户端试探性发出请求
   - 如果试探请求依旧被拒绝，就可以再次等待一段时间
5. 逐步加大流量
````

## 降级

````markmap
---
markmap:
  colorFreezeLevel: 4
---

# 微服务降级

## 基本概念

### 与熔断基本一致
- 判定节点健康
- 恢复
- 抖动

### 如何降级

#### 跨服务降级
##### 根据业务价值来判定是否降级

##### 3 种方案
- 全部停掉
- 停掉部分节点
- 停止访问某些资源
  - 场景：第三方崩溃

#### 有损服务
- 返回默认值
- 禁用可观测性组件
- 同步转异步
- 简化流程（注意审核）

## 亮点方案

### 读写服务降级写服务
#### 读服务更加重要
#### 读服务 QPS 更高
#### 写服务显著提高服务器负载

#### 合并部署服务降级策略
- BC 端降级 B 端服务
- VIP 和非 VIP 降级非 VIP
- 付费和非付费降级非付费

### 快慢路径降级慢路径
- 正常请求先快路径后慢路径
- 降级请求只执行快路径
````

## 限流

````markmap
---
markmap:
  colorFreezeLevel: 4
---

# 微服务限流

## 基本概念

### 算法

#### 静态算法
- 令牌桶
- 漏桶
- 固定窗口
- 滑动窗口

#### 动态算法（自适应算法）
- 可强调整参考 TCP 流量调度
- BBR
- 自定义算法(类似于熔断、降级, 需要选择合适的指标)

### 对象

#### 单机 OR 集群
- 集群限流依赖于 Redis
- 网关在集群限流时，可以不使用 Redis

#### 业务相关限流
- 针对非 VIP 用户
- IP 限流
- 业务 ID 限流

### 做法（注意对比熔断限流）
- 同步阻塞
- 同步转异步
- 调整负载均衡算法

## 计算阈值

### 观测线上服务性能数据
- 数据解读
  - QPS 与响应时间
  - 资源利用率
  - 吞吐量的关系

### 压测（第一选择）

#### 选择点
- 性能优先 A
- 并发数优先 B
- 吞吐量优先 C

### 微创新方案：借鉴
- 参考类似服务
- 参考按比例转化服务

### 手动计算（不准，凑合用）
- 数据库操作
- 微服务调用
- Redis 访问
- Kafka 操作
- 其他耗时操作
````

## 隔离

````markmap
---
markmap:
  colorFreezeLevel: 3
---

# 微服务隔离

## 基本原则
- 核心与非核心隔离
- 核心与核心隔离

## 优点
- 提高可用性
- 提高性能
- 提高安全性

## 常见措施

### 机房隔离

### 实例隔离

### 分组隔离
- BC 端隔离
- VIP 和非 VIP 隔离
- 读写隔离: 跟命令查询职责分离原则是一回事
- 快慢隔离: 和慢任务隔离是一个思路

### 连接池隔离
- 微服务连接池
- 数据库连接池
- 其他连接池

### 线程池隔离
- ⚠️ 有些语言没有线程池概念

### 第三方依赖隔离

#### Redis 隔离
- 核心业务采用单独 Redis 集群
- 开启持久化的 Redis 作为单独集群

#### 物理数据库隔离

#### 消息队列隔离
- 日志采集 Kafka 和业务 Kafka 隔离

#### 其他中间件隔离

## 方案
- 慢任务隔离
- 制作库与线上库分离
````

## 超时控制

````markmap
---
markmap:
  colorFreezeLevel: 3
---

# 微服务超时控制

## 基础知识

### 超时控制目标
- 用户体验
- 及时释放资源: ‼️ 提升可用性的关键

### 超时控制形态
- 调用超时控制
- 链路超时控制: 比较考验研发能力

### 确定超时时间
- 用户体验
- 响应时间
  - 99 线 / 999 线
- 压测
- 代码

### 超时中断业务
- 要点：手动检测

### 监听超时时间

#### 客户端监听
- 超时不发请求
- 已发之后超时，丢弃响应

#### 客户端与服务端同时监听
- 服务端收到请求已超时，不执行
- 服务端返回超时响应之后，丢弃应用响应

## 链路超时控制

### 超时时间字段（链路元数据）
- HTTP
  - HTTP 头部
- RPC（Dubbo 中的超时字段）
  - 协议头

### 超时时间值
#### 剩余超时时间
- 估计网络传输时间
- 跨地区传递: 可能网络传输问题比较严重
#### 超时时间戳
- 时钟同步问题（分布式系统常见问题）
  - 正常不用管，非常轻微
  - 时钟回拨（闰秒）
  - 不同云服务商



### 控制不住
- 要求下游优化性能
- 本地缓存调用结果
````

## 调用第三方

````markmap
---
markmap:
  colorFreezeLevel: 3
---

# 调用第三方平台

## 基本措施

### 一致性抽象
- 提高研发效率
- 高可扩展性

### 客户端治理
- 限流
- 重试: 只能用于幂等接口

### 可观测性支持
- 日志
- metrics
  - Prometheus
- tracing
  - ZipKin
  - SkyWalking
- 告警

### 测试支持

#### mock 响应
- 成功响应
- 失败响应
- 超时

#### mock 回调

## 亮点方案

### 同步转异步
- 对时效性要求不高的接口
- 临时存储请求数据
- 利用消息队列解耦

### 自动替换第三方
- 判断一个服务是否健康

### 压测支持
- 模拟响应时间
- 模拟容错措施
- 全链路流量分发
````

## 综合方案

````markmap
---
markmap:
  colorFreezeLevel: 3
---

# 高可用微服务架构

## 高可用

### 容错
- 自身服务故障（⭐ 最重要）
- 依赖的服务故障
- 基础设施故障

### 限制影响范围
- 业务损失小
- 被影响用户少
- 被影响组件少

### 与组织建设有关

#### 快速发现、修复
- 完善的监控、告警以及自动故障处理机制

#### 规范变更流程
- 发布流程
- 配置变更流程

## 面试基本思路

### 发现问题(可替换成自己工作中更具体的问题)
- 监控告警不完善
- 缺乏服务治理
- 缺乏合理的变更流程

### 计划方案
- 引入监控和告警
- 引入服务治理措施
- 引入第三方高可用方案
- 拆分共同依赖
- 规范变更流程

### 落地实施

#### 监控告警
- 监控业务
- 监控依赖
  - 软件依赖
  - 硬件依赖（研发关注较少）

#### 服务治理
- 熔断
- 降级
- 限流
- 隔离
- 第三方调用等

#### 引入第三方高可用方案

#### 拆分共同依赖

### 取得效果
- 99 变 999
- Bug 变少

### 后续改进
- 进一步减少共同依赖

## 亮点方案

### 异步 / 解耦
- 消息队列

### 自动故障处理
- 但凡需要你手动修复的数据，都可以考虑自动修复
````